/// <reference types="node" />
import { IncomingMessage } from "http";
import { Readable } from "stream";
/**
 * Generic class for Words Cloud API response
 */
export declare class WordsIncomingMessage<T> {
    /**
     * Gets or sets raw response
     */
    response: IncomingMessage;
    /**
     * Get or set parsed response
     */
    body: T;
}
/**
 * Attribute description
 */
export declare class AttributeInfo {
    /**
     * Gets or sets attribute name
     */
    name: string;
    /**
     * Gets or sets attribute base name
     */
    baseName: string;
    /**
     * Gets or sets attribute type name
     */
    type: string;
}
/**
 * Api error.
 */
export declare class ApiError {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets api error code.
     */
    code: string;
    /**
     * Gets or sets error message.
     */
    message: string;
    /**
     * Gets or sets error description.
     */
    description: string;
    /**
     * Gets or sets server datetime.
     */
    dateTime: Date;
    /**
     * Gets or sets inner error.
     */
    innerError: ApiError;
    constructor(init?: Partial<ApiError>);
}
/**
 * DTO for bookmark updating.
 */
export declare class BookmarkData {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets the name of the bookmark.
     */
    name: string;
    /**
     * Gets or sets the text enclosed in the bookmark.
     */
    text: string;
    constructor(init?: Partial<BookmarkData>);
}
/**
 * container class for individual bookmarks outline level.
 */
export declare class BookmarksOutlineLevelData {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets specify the bookmark's name.
     */
    name: string;
    /**
     * Gets or sets specify the bookmark's level.
     */
    bookmarksOutlineLevel: number;
    constructor(init?: Partial<BookmarksOutlineLevelData>);
}
/**
 * Represents a single classification result.
 */
export declare class ClassificationResult {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets the name of the class.
     */
    className: string;
    /**
     * Gets or sets the probability of class.
     */
    classProbability: number;
    constructor(init?: Partial<ClassificationResult>);
}
/**
 * Container class for compare documents.
 */
export declare class CompareData {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets path to document to compare at the server.
     */
    comparingWithDocument: string;
    /**
     * Gets or sets initials of the author to use for revisions.
     */
    author: string;
    /**
     * Gets or sets the date and time to use for revisions.
     */
    dateTime: Date;
    constructor(init?: Partial<CompareData>);
}
/**
 * Represents Words document DTO.
 */
export declare class Document {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets a list of links that originate from this document.
     */
    links: Array<Link>;
    /**
     * Gets or sets the name of the file.
     */
    fileName: string;
    /**
     * Gets or sets the original format of the document.
     */
    sourceFormat: Document.SourceFormatEnum;
    /**
     * Gets or sets a value indicating whether returns true if the document is encrypted and requires a password to open.
     */
    isEncrypted: boolean;
    /**
     * Gets or sets a value indicating whether returns true if the document contains a digital signature. This property merely informs that a digital signature is present on a document, but it does not specify whether the signature is valid or not.
     */
    isSigned: boolean;
    /**
     * Gets or sets returns document properties.
     */
    documentProperties: DocumentProperties;
    constructor(init?: Partial<Document>);
}
/**
 * Enums for Document
 */
export declare namespace Document {
    enum SourceFormatEnum {
        Unknown,
        Doc,
        Dot,
        DocPreWord60,
        Docx,
        Docm,
        Dotx,
        Dotm,
        FlatOpc,
        Rtf,
        WordML,
        Html,
        Mhtml,
        Epub,
        Text,
        Odt,
        Ott,
        Pdf,
        Xps,
        Tiff,
        Svg
    }
}
/**
 * Represents a document which will be appended to the original resource document.
 */
export declare class DocumentEntry {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets path to document to append at the server.
     */
    href: string;
    /**
     * Gets or sets defines which formatting will be used: appended or destination document.Can be KeepSourceFormatting or UseDestinationStyles.
     */
    importFormatMode: string;
    constructor(init?: Partial<DocumentEntry>);
}
/**
 * Represents a list of documents which will be appended to the original resource document.
 */
export declare class DocumentEntryList {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets list of documents.
     */
    documentEntries: Array<DocumentEntry>;
    constructor(init?: Partial<DocumentEntryList>);
}
/**
 * Represents a position in the document tree.
 */
export declare class DocumentPosition {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets link to  node.
     */
    node: NodeLink;
    /**
     * Gets or sets offset into the node.
     */
    offset: number;
    constructor(init?: Partial<DocumentPosition>);
}
/**
 * Container for the document's statistical data.
 */
export declare class DocumentStatData {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets total count of words in the document.
     */
    wordCount: number;
    /**
     * Gets or sets total count of paragraphs in the document.
     */
    paragraphCount: number;
    /**
     * Gets or sets total count of pages in the document.
     */
    pageCount: number;
    /**
     * Gets or sets detailed statistics of footnotes.
     */
    footnotesStatData: FootnotesStatData;
    /**
     * Gets or sets detailed statistics of all pages.
     */
    pageStatData: Array<PageStatData>;
    constructor(init?: Partial<DocumentStatData>);
}
/**
 * Container class for Downsample options.
 */
export declare class DownsampleOptionsData {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets specifies whether images should be downsampled.
     */
    downsampleImages: boolean;
    /**
     * Gets or sets specifies the resolution in pixels per inch which the images should be downsampled to.
     */
    resolution: number;
    /**
     * Gets or sets specifies the threshold resolution in pixels per inch. If resolution of an image in the document is less than threshold value, the downsampling algorithm will not be applied. A value of 0 means the threshold check is not used and all images that can be reduced in size are downsampled.
     */
    resolutionThreshold: number;
    constructor(init?: Partial<DownsampleOptionsData>);
}
/**
 * The error details
 */
export declare class ErrorDetails {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * The request id.
     */
    requestId: string;
    /**
     * Error datetime.
     */
    errorDateTime: Date;
    constructor(init?: Partial<ErrorDetails>);
}
/**
 * Files list
 */
export declare class FilesList {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Files and folders contained by folder .
     */
    value: Array<StorageFile>;
    constructor(init?: Partial<FilesList>);
}
/**
 * File upload result
 */
export declare class FilesUploadResult {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * List of uploaded file names
     */
    uploaded: Array<string>;
    /**
     * List of errors.
     */
    errors: Array<StorageApiError>;
    constructor(init?: Partial<FilesUploadResult>);
}
/**
 * Font info.
 */
export declare class FontInfo {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets family name of the font.
     */
    fontFamilyName: string;
    /**
     * Gets or sets full name of the font.
     */
    fullFontName: string;
    /**
     * Gets or sets version string of the font.
     */
    version: string;
    /**
     * Gets or sets path to the font file if any.
     */
    filePath: string;
    constructor(init?: Partial<FontInfo>);
}
/**
 * Container for the footnotes statistical data.
 */
export declare class FootnotesStatData {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets total count of words in footnotes.
     */
    wordCount: number;
    /**
     * Gets or sets total count of paragraphs in footnotes.
     */
    paragraphCount: number;
    constructor(init?: Partial<FootnotesStatData>);
}
/**
 * Allows to specify additional System.Drawing.Graphics quality options.
 */
export declare class GraphicsQualityOptionsData {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets a value that specifies how composited images are drawn to this Graphics.
     */
    compositingMode: GraphicsQualityOptionsData.CompositingModeEnum;
    /**
     * Gets or sets the rendering quality of composited images drawn to this Graphics.
     */
    compositingQuality: GraphicsQualityOptionsData.CompositingQualityEnum;
    /**
     * Gets or sets the interpolation mode associated with this Graphics.
     */
    interpolationMode: GraphicsQualityOptionsData.InterpolationModeEnum;
    /**
     * Gets or sets the rendering quality for this Graphics.
     */
    smoothingMode: GraphicsQualityOptionsData.SmoothingModeEnum;
    /**
     * Gets or sets text layout information (such as alignment, orientation and tab stops) display manipulations (such as ellipsis insertion and national digit substitution) and OpenType features.
     */
    stringFormat: StringFormatData;
    /**
     * Gets or sets the rendering mode for text associated with this Graphics.
     */
    textRenderingHint: GraphicsQualityOptionsData.TextRenderingHintEnum;
    constructor(init?: Partial<GraphicsQualityOptionsData>);
}
/**
 * Enums for GraphicsQualityOptionsData
 */
export declare namespace GraphicsQualityOptionsData {
    enum CompositingModeEnum {
        SourceOver,
        SourceCopy
    }
    enum CompositingQualityEnum {
        Default,
        HighSpeed,
        HighQuality,
        GammaCorrected,
        AssumeLinear,
        Invalid
    }
    enum InterpolationModeEnum {
        Default,
        Low,
        High,
        Bilinear,
        Bicubic,
        NearestNeighbor,
        HighQualityBilinear,
        HighQualityBicubic,
        Invalid
    }
    enum SmoothingModeEnum {
        Default,
        HighSpeed,
        HighQuality,
        None,
        AntiAlias,
        Invalid
    }
    enum TextRenderingHintEnum {
        SystemDefault,
        SingleBitPerPixelGridFit,
        SingleBitPerPixel,
        AntiAliasGridFit,
        AntiAlias,
        ClearTypeGridFit
    }
}
/**
 * Provides information for the object link. This is supposed to be an atom:link, therefore it should have all attributes specified here http://tools.ietf.org/html/rfc4287#section-4.2.7.
 */
export declare class Link {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets the \"href\" attribute contains the link's IRI. atom:link elements MUST have an href attribute, whose value MUST be a IRI reference.
     */
    href: string;
    /**
     * Gets or sets atom:link elements MAY have a \"rel\" attribute that indicates the link relation type.  If the \"rel\" attribute is not present, the link element MUST be interpreted as if the link relation type is \"alternate\".
     */
    rel: string;
    /**
     * Gets or sets on the link element, the \"type\" attribute's value is an advisory media type: it is a hint about the type of the representation that is expected to be returned when the value of the href attribute is dereferenced.  Note that the type attribute does not override the actual media type returned with the representation.
     */
    type: string;
    /**
     * Gets or sets the \"title\" attribute conveys human-readable information about the link.  The content of the \"title\" attribute is Language-Sensitive.
     */
    title: string;
    constructor(init?: Partial<Link>);
}
/**
 * Reference to document.
 */
export declare class LinkElement {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets link to the document.
     */
    link: WordsApiLink;
    constructor(init?: Partial<LinkElement>);
}
/**
 * Contains data for load web document.
 */
export declare class LoadWebDocumentData {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets web document url.
     */
    loadingDocumentUrl: string;
    /**
     * Gets or sets save options.
     */
    saveOptions: SaveOptionsData;
    constructor(init?: Partial<LoadWebDocumentData>);
}
/**
 * container class for options of metafile rendering.
 */
export declare class MetafileRenderingOptionsData {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets determines how EMF+ Dual metafiles should be rendered.
     */
    emfPlusDualRenderingMode: string;
    /**
     * Gets or sets a value determining whether or not the raster operations should be emulated.
     */
    emulateRasterOperations: boolean;
    /**
     * Gets or sets determines how metafile images should be rendered.
     */
    renderingMode: string;
    /**
     * Gets or sets determines how WMF metafiles with embedded EMF metafiles should be rendered.
     */
    useEmfEmbeddedToWmf: boolean;
    /**
     * Gets or sets a value determining whether or not to scale fonts in WMF metafile according to metafile size on the page. The default value is true.
     */
    scaleWmfFontsToMetafileSize: boolean;
    constructor(init?: Partial<MetafileRenderingOptionsData>);
}
/**
 * result of the operation which modifies the original document and saves the result.
 */
export declare class ModificationOperationResult {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets link to the source document (source for the modification operation).
     */
    source: FileLink;
    /**
     * Gets or sets link to the dest document (result of the modification operation).
     */
    dest: FileLink;
    constructor(init?: Partial<ModificationOperationResult>);
}
/**
 * container class for outline options.
 */
export declare class OutlineOptionsData {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets allows to specify individual bookmarks outline level.
     */
    bookmarksOutlineLevels: Array<BookmarksOutlineLevelData>;
    /**
     * Gets or sets specifies the default level in the document outline at which to display Word bookmarks.
     */
    defaultBookmarksOutlineLevel: number;
    /**
     * Gets or sets a value determining whether or not to create missing outline levels     when the document is exported.     Default value for this property is false.
     */
    createMissingOutlineLevels: boolean;
    /**
     * Gets or sets specifies whether or not to create outlines for headings (paragraphs formatted     with the Heading styles) inside tables.
     */
    createOutlinesForHeadingsInTables: boolean;
    /**
     * Gets or sets specifies how many levels in the document outline to show expanded when the file is viewed.
     */
    expandedOutlineLevels: number;
    /**
     * Gets or sets specifies how many levels of headings (paragraphs formatted with the Heading styles) to include in the document outline.
     */
    headingsOutlineLevels: number;
    constructor(init?: Partial<OutlineOptionsData>);
}
/**
 * Class is used for insert page number request building.
 */
export declare class PageNumber {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets page number format, e.g. \"{PAGE} of {NUMPAGES}\".
     */
    format: string;
    /**
     * Gets or sets text alignment, possible values are left, right, center or justify.
     */
    alignment: string;
    /**
     * Gets or sets a value indicating whether if true the page number is added at the top of the page, else at the bottom.
     */
    isTop: boolean;
    /**
     * Gets or sets a value indicating whether if true the page number is added on first page too.
     */
    setPageNumberOnFirstPage: boolean;
    constructor(init?: Partial<PageNumber>);
}
/**
 * Container for the page's statistical data.
 */
export declare class PageStatData {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets page number.
     */
    pageNumber: number;
    /**
     * Gets or sets total count of words in the page.
     */
    wordCount: number;
    /**
     * Gets or sets total count of paragraphs in the page.
     */
    paragraphCount: number;
    /**
     * Gets or sets detailed statistics of footnotes.
     */
    footnotesStatData: FootnotesStatData;
    constructor(init?: Partial<PageStatData>);
}
/**
 * Paragraph element.
 */
export declare class ParagraphInsert {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets paragraph's text.
     */
    text: string;
    constructor(init?: Partial<ParagraphInsert>);
}
/**
 * container class for details of digital signature.
 */
export declare class PdfDigitalSignatureDetailsData {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets certificate's filename using for signing.
     */
    certificateFilename: string;
    /**
     * Gets or sets hash algorithm.
     */
    hashAlgorithm: string;
    /**
     * Gets or sets location of the signing.
     */
    location: string;
    /**
     * Gets or sets reason for the signing.
     */
    reason: string;
    /**
     * Gets or sets date of the signing.
     */
    signatureDate: Date;
    constructor(init?: Partial<PdfDigitalSignatureDetailsData>);
}
/**
 * container class for details of encryption.
 */
export declare class PdfEncryptionDetailsData {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets specifies the encryption algorithm to use.
     */
    encryptionAlgorithm: string;
    /**
     * Gets or sets specifies the owner password for the encrypted PDF document.
     */
    ownerPassword: string;
    /**
     * Gets or sets specifies the operations that are allowed to a user on an encrypted PDF document.
     */
    permissions: string;
    /**
     * Gets or sets specifies the user password required for opening the encrypted PDF document.
     */
    userPassword: string;
    constructor(init?: Partial<PdfEncryptionDetailsData>);
}
/**
 * Preferred width.
 */
export declare class PreferredWidth {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets the unit of measure used for this preferred width value.
     */
    type: PreferredWidth.TypeEnum;
    /**
     * Gets or sets the preferred width value. The unit of measure is specified in the  property.
     */
    value: number;
    constructor(init?: Partial<PreferredWidth>);
}
/**
 * Enums for PreferredWidth
 */
export declare namespace PreferredWidth {
    enum TypeEnum {
        Auto,
        Percent,
        Points
    }
}
/**
 * Container for the data about protection of the document.
 */
export declare class ProtectionData {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets type of the protection.
     */
    protectionType: string;
    constructor(init?: Partial<ProtectionData>);
}
/**
 * Request on changing of protection.
 */
export declare class ProtectionRequest {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets current password.
     */
    password: string;
    /**
     * Gets or sets new password.
     */
    newPassword: string;
    /**
     * Gets or sets new type of protection.
     */
    protectionType: string;
    constructor(init?: Partial<ProtectionRequest>);
}
/**
 * Range element.
 */
export declare class RangeDocument {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets name for new document.
     */
    documentName: string;
    constructor(init?: Partial<RangeDocument>);
}
/**
 * Range element.
 */
export declare class ReplaceRange {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets range's text.
     */
    text: string;
    /**
     * Gets or sets range's text type.
     */
    textType: ReplaceRange.TextTypeEnum;
    constructor(init?: Partial<ReplaceRange>);
}
/**
 * Enums for ReplaceRange
 */
export declare namespace ReplaceRange {
    enum TextTypeEnum {
        Text,
        Html
    }
}
/**
 * Class for document replace text request building.
 */
export declare class ReplaceTextParameters {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets old text value (or regex pattern ) to replace.
     */
    oldValue: string;
    /**
     * Gets or sets new text value to replace by.
     */
    newValue: string;
    /**
     * Gets or sets a value indicating whether flag, true means the search is case-sensitive; false means the search is not case-sensitive.
     */
    isMatchCase: boolean;
    /**
     * Gets or sets a value indicating whether flag, means that only whole word matched are replaced.
     */
    isMatchWholeWord: boolean;
    /**
     * Gets or sets a value indicating whether flag, means that  contains regex expression.
     */
    isOldValueRegex: boolean;
    constructor(init?: Partial<ReplaceTextParameters>);
}
/**
 * base container class for save options data.
 */
export declare class SaveOptionsData {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets format of save.
     */
    saveFormat: string;
    /**
     * Gets or sets name of destination file.
     */
    fileName: string;
    /**
     * Gets or sets a value determining how DrawingML shapes are rendered. { Fallback | DrawingML }.
     */
    dmlRenderingMode: string;
    /**
     * Gets or sets a value determining how DrawingML effects are rendered. { Simplified | None | Fine }.
     */
    dmlEffectsRenderingMode: string;
    /**
     * Gets or sets controls zip output or not. Default value is false.
     */
    zipOutput: boolean;
    /**
     * Gets or sets a value determining whether the Aspose.Words.Properties.BuiltInDocumentProperties.LastSavedTime property is updated before saving.
     */
    updateLastSavedTimeProperty: boolean;
    /**
     * Gets or sets value determining whether content of  is updated before saving.
     */
    updateSdtContent: boolean;
    /**
     * Gets or sets a value determining if fields should be updated before saving the document to a fixed page format. Default value for this property is. true
     */
    updateFields: boolean;
    constructor(init?: Partial<SaveOptionsData>);
}
/**
 * Result of saving.
 */
export declare class SaveResult {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets link to source document.
     */
    sourceDocument: FileLink;
    /**
     * Gets or sets link to destination document.
     */
    destDocument: FileLink;
    /**
     * Gets or sets links to additional items (css, images etc).
     */
    additionalItems: Array<FileLink>;
    constructor(init?: Partial<SaveResult>);
}
/**
 * Result of search operation.
 */
export declare class SearchResult {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets link to result range start node.
     */
    rangeStart: DocumentPosition;
    /**
     * Gets or sets link to result range end node.
     */
    rangeEnd: DocumentPosition;
    constructor(init?: Partial<SearchResult>);
}
/**
 * Result of splitting document.
 */
export declare class SplitDocumentResult {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets linkt to the source document.
     */
    sourceDocument: FileLink;
    /**
     * Gets or sets array of pages.
     */
    pages: Array<FileLink>;
    /**
     * Gets or sets link to the file archive with pages.
     */
    zippedPages: FileLink;
    constructor(init?: Partial<SplitDocumentResult>);
}
/**
 * Error
 */
export declare class StorageApiError {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Code
     */
    code: string;
    /**
     * Message
     */
    message: string;
    /**
     * Description
     */
    description: string;
    /**
     * Inner Error
     */
    innerError: ErrorDetails;
    constructor(init?: Partial<StorageApiError>);
}
/**
 * File or folder information
 */
export declare class StorageFile {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * File or folder name.
     */
    name: string;
    /**
     * True if it is a folder.
     */
    isFolder: boolean;
    /**
     * File or folder last modified .
     */
    modifiedDate: Date;
    /**
     * File or folder size.
     */
    size: number;
    /**
     * File or folder path.
     */
    path: string;
    constructor(init?: Partial<StorageFile>);
}
/**
 * Child nodes of  or .
 */
export declare class StoryChildNodes {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets child nodes.
     */
    childNodes: Array<NodeLink>;
    constructor(init?: Partial<StoryChildNodes>);
}
/**
 * Allows to specify System.Drawing.StringFormat options.
 */
export declare class StringFormatData {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets horizontal alignment of the string.
     */
    alignment: StringFormatData.AlignmentEnum;
    /**
     * Gets or sets a System.Drawing.StringFormatFlags enumeration that contains formatting information.
     */
    formatFlags: StringFormatData.FormatFlagsEnum;
    /**
     * Gets or sets the System.Drawing.Text.HotkeyPrefix object for this System.Drawing.StringFormat object.
     */
    hotkeyPrefix: StringFormatData.HotkeyPrefixEnum;
    /**
     * Gets or sets the vertical alignment of the string.
     */
    lineAlignment: StringFormatData.LineAlignmentEnum;
    /**
     * Gets or sets the System.Drawing.StringTrimming enumeration for this System.Drawing.StringFormat object.
     */
    trimming: StringFormatData.TrimmingEnum;
    constructor(init?: Partial<StringFormatData>);
}
/**
 * Enums for StringFormatData
 */
export declare namespace StringFormatData {
    enum AlignmentEnum {
        Near,
        Center,
        Far
    }
    enum FormatFlagsEnum {
        DirectionRightToLeft,
        DirectionVertical,
        FitBlackBox,
        DisplayFormatControl,
        NoFontFallback,
        MeasureTrailingSpaces,
        NoWrap,
        LineLimit,
        NoClip
    }
    enum HotkeyPrefixEnum {
        None,
        Show,
        Hide
    }
    enum LineAlignmentEnum {
        Near,
        Center,
        Far
    }
    enum TrimmingEnum {
        None,
        Character,
        Word,
        EllipsisCharacter,
        EllipsisWord,
        EllipsisPath
    }
}
/**
 * Table cell element.
 */
export declare class TableCellInsert {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets table cell will be inserted after cell with specified 0-based index.
     */
    insertAfter: number;
    constructor(init?: Partial<TableCellInsert>);
}
/**
 * Table element.
 */
export declare class TableInsert {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets table will be inserted before specified position.
     */
    position: DocumentPosition;
    /**
     * Gets or sets count of columns. Default is 2.
     */
    columnsCount: number;
    /**
     * Gets or sets count of rows. Default is 2.
     */
    rowsCount: number;
    constructor(init?: Partial<TableInsert>);
}
/**
 * Table row element.
 */
export declare class TableRowInsert {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets table row will be inserted after row with specified 0-based index.
     */
    insertAfter: number;
    /**
     * Gets or sets count of columns. Default is 1.
     */
    columnsCount: number;
    constructor(init?: Partial<TableRowInsert>);
}
/**
 * Class for insert watermark text request building.
 */
export declare class WatermarkText {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets the watermark text.
     */
    text: string;
    /**
     * Gets or sets the watermark rotation angle.
     */
    rotationAngle: number;
    constructor(init?: Partial<WatermarkText>);
}
/**
 * Base class for all responses.
 */
export declare class WordsResponse {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets request Id.
     */
    requestId: string;
    constructor(init?: Partial<WordsResponse>);
}
/**
 * Utility class for  serialization.
 */
export declare class XmlColor {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets hTML string color representation.
     */
    web: string;
    /**
     * Gets or sets alpha component of color structure.
     */
    alpha: number;
    constructor(init?: Partial<XmlColor>);
}
/**
 * The list of fonts, available for document processing.
 */
export declare class AvailableFontsResponse extends WordsResponse {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets the list of addititional fonts, provided by aspose team.
     */
    additionalFonts: Array<FontInfo>;
    /**
     * Gets or sets custom user fonts (from user file storage). To use them, you should specify \"fontsLocation\" parameter in any request.
     */
    customFonts: Array<FontInfo>;
    /**
     * Gets or sets the list of system fonts, availiable on the server.
     */
    systemFonts: Array<FontInfo>;
    constructor(init?: Partial<AvailableFontsResponse>);
}
/**
 * Represents a single bookmark.
 */
export declare class Bookmark extends LinkElement {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets the name of the bookmark.
     */
    name: string;
    /**
     * Gets or sets the text enclosed in the bookmark.
     */
    text: string;
    constructor(init?: Partial<Bookmark>);
}
/**
 * This response should be returned by the service when handling:  GET bookmarks/{bookmarkName}.
 */
export declare class BookmarkResponse extends WordsResponse {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets bookmark.
     */
    bookmark: Bookmark;
    constructor(init?: Partial<BookmarkResponse>);
}
/**
 * Represents an array of bookmarks.
 */
export declare class Bookmarks extends LinkElement {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets array of bookmarks.
     */
    bookmarkList: Array<Bookmark>;
    constructor(init?: Partial<Bookmarks>);
}
/**
 * This response should be returned by the service when handling:  GET bookmarks.
 */
export declare class BookmarksResponse extends WordsResponse {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets bookmarks which are contained in document.
     */
    bookmarks: Bookmarks;
    constructor(init?: Partial<BookmarksResponse>);
}
/**
 * Represents a border of an object.
 */
export declare class Border extends LinkElement {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets the border type.
     */
    borderType: Border.BorderTypeEnum;
    /**
     * Gets or sets the border color.
     */
    color: XmlColor;
    /**
     * Gets or sets distance of the border from text or from the page edge in points.
     */
    distanceFromText: number;
    /**
     * Gets or sets the border style.
     */
    lineStyle: Border.LineStyleEnum;
    /**
     * Gets or sets the border width in points.
     */
    lineWidth: number;
    /**
     * Gets or sets a value indicating whether the border has a shadow.
     */
    shadow: boolean;
    constructor(init?: Partial<Border>);
}
/**
 * Enums for Border
 */
export declare namespace Border {
    enum BorderTypeEnum {
        Bottom,
        Left,
        Right,
        Top,
        Horizontal,
        Vertical,
        DiagonalDown,
        DiagonalUp,
        None
    }
    enum LineStyleEnum {
        None,
        Single,
        Thick,
        Double,
        Hairline,
        Dot,
        DashLargeGap,
        DotDash,
        DotDotDash,
        Triple,
        ThinThickSmallGap,
        ThickThinSmallGap,
        ThinThickThinSmallGap,
        ThinThickMediumGap,
        ThickThinMediumGap,
        ThinThickThinMediumGap,
        ThinThickLargeGap,
        ThickThinLargeGap,
        ThinThickThinLargeGap,
        Wave,
        DoubleWave,
        DashSmallGap,
        DashDotStroker,
        Emboss3D,
        Engrave3D,
        Outset,
        Inset
    }
}
/**
 * This response should be returned by the service when handling: GET {nodeWithBorders}/borders.
 */
export declare class BorderResponse extends WordsResponse {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets table.
     */
    border: Border;
    constructor(init?: Partial<BorderResponse>);
}
/**
 * Collection of borders.
 */
export declare class BordersCollection extends LinkElement {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets collection of comments.
     */
    list: Array<Border>;
    constructor(init?: Partial<BordersCollection>);
}
/**
 * This response should be returned by the service when handling: GET {nodeWithBorders}/borders.
 */
export declare class BordersResponse extends WordsResponse {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets table.
     */
    borders: BordersCollection;
    constructor(init?: Partial<BordersResponse>);
}
/**
 * This response should be returned by the service when handling: PUT http://api.aspose.com/v4.0/words/classify.
 */
export declare class ClassificationResponse extends WordsResponse {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets best class name.
     */
    bestClassName: string;
    /**
     * Gets or sets best class probability.
     */
    bestClassProbability: number;
    /**
     * Gets or sets array of best classes results.
     */
    bestResults: Array<ClassificationResult>;
    constructor(init?: Partial<ClassificationResponse>);
}
/**
 * Comment link.
 */
export declare class CommentLink extends LinkElement {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    constructor(init?: Partial<CommentLink>);
}
/**
 * This response should be returned by the service when handling: GET http://api.aspose.com/v4.0/words/Test.doc/comments/0.
 */
export declare class CommentResponse extends WordsResponse {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets comment information.
     */
    comment: Comment;
    constructor(init?: Partial<CommentResponse>);
}
/**
 * Collection of comments.
 */
export declare class CommentsCollection extends LinkElement {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets collection of comments.
     */
    commentList: Array<Comment>;
    constructor(init?: Partial<CommentsCollection>);
}
/**
 * This response should be returned by the service when handling: GET http://api.aspose.com/v4.0/words/Test.doc/comments.
 */
export declare class CommentsResponse extends WordsResponse {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets collection of comments.
     */
    comments: CommentsCollection;
    constructor(init?: Partial<CommentsResponse>);
}
/**
 * container class for doc/dot save options.
 */
export declare class DocSaveOptionsData extends SaveOptionsData {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets When false, small metafiles are not compressed for performance reason. Default value is true, all metafiles are compressed regardless of its size.
     */
    alwaysCompressMetafiles: boolean;
    /**
     * Gets or sets password.
     */
    password: string;
    /**
     * Gets or sets When false, PictureBullet data is not saved to output document. Default value is true.
     */
    savePictureBullet: boolean;
    /**
     * Gets or sets determine whether or not save RoutingSlip data saved to output document.
     */
    saveRoutingSlip: boolean;
    constructor(init?: Partial<DocSaveOptionsData>);
}
/**
 * Collection of document properties.
 */
export declare class DocumentProperties extends LinkElement {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets collection of document properties.
     */
    list: Array<DocumentProperty>;
    constructor(init?: Partial<DocumentProperties>);
}
/**
 * This response should be returned by the service when handling:  GET /documentProperties.
 */
export declare class DocumentPropertiesResponse extends WordsResponse {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets collection of document properties.
     */
    documentProperties: DocumentProperties;
    constructor(init?: Partial<DocumentPropertiesResponse>);
}
/**
 * Words document property DTO.
 */
export declare class DocumentProperty extends LinkElement {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets a value indicating whether flag indicates whether the property is built-in or not. If true the property is built-in, if false the property is custom.
     */
    builtIn: boolean;
    /**
     * Gets or sets name of the document property.
     */
    name: string;
    /**
     * Gets or sets string value of the document property.
     */
    value: string;
    constructor(init?: Partial<DocumentProperty>);
}
/**
 * This response should be returned by the service when handling:  GET documentProperties/{propertyName}.
 */
export declare class DocumentPropertyResponse extends WordsResponse {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets document property.
     */
    documentProperty: DocumentProperty;
    constructor(init?: Partial<DocumentPropertyResponse>);
}
/**
 * Represents the response with document description.
 */
export declare class DocumentResponse extends WordsResponse {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets document description.
     */
    document: Document;
    constructor(init?: Partial<DocumentResponse>);
}
/**
 * Represents drawing objects collection DTO.
 */
export declare class DrawingObjectCollection extends LinkElement {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets collection of DrawingObjects links.
     */
    list: Array<LinkElement>;
    constructor(init?: Partial<DrawingObjectCollection>);
}
/**
 * Response for \"drawingObjects/n\" resource.
 */
export declare class DrawingObjectResponse extends WordsResponse {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets drawing object.
     */
    drawingObject: DrawingObject;
    constructor(init?: Partial<DrawingObjectResponse>);
}
/**
 * This response should be returned by the service when handling:  GET /drawingObjects.
 */
export declare class DrawingObjectsResponse extends WordsResponse {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets collection of drawing objects.
     */
    drawingObjects: DrawingObjectCollection;
    constructor(init?: Partial<DrawingObjectsResponse>);
}
/**
 * Represents DTO for collection of fields.
 */
export declare class FieldCollection extends LinkElement {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets collection of fields.
     */
    list: Array<Field>;
    constructor(init?: Partial<FieldCollection>);
}
/**
 * Represents a collection of merge fields within a document.
 */
export declare class FieldNames extends LinkElement {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets collection of fields names.
     */
    names: Array<string>;
    constructor(init?: Partial<FieldNames>);
}
/**
 * This response should be returned by the service when handling:  GET /{name}/mailMergeFieldNames.
 */
export declare class FieldNamesResponse extends WordsResponse {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets collection of mail merge fields.
     */
    fieldNames: FieldNames;
    constructor(init?: Partial<FieldNamesResponse>);
}
/**
 * This response should be returned by the service when handling: GET http://api.aspose.com/v4.0/words/Test.doc/paragraphs/{0}/fields/{1}.
 */
export declare class FieldResponse extends WordsResponse {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets field information.
     */
    field: Field;
    constructor(init?: Partial<FieldResponse>);
}
/**
 * This response should be returned by the service when handling: GET http://api.aspose.com/v4.0/words/Test.doc/{nodePath}/fields.
 */
export declare class FieldsResponse extends WordsResponse {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets collection of fields.
     */
    fields: FieldCollection;
    constructor(init?: Partial<FieldsResponse>);
}
/**
 * Provides information for the file link.
 */
export declare class FileLink extends Link {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    constructor(init?: Partial<FileLink>);
}
/**
 * Contains common options that can be specified when saving a document into fixed page formats (PDF, XPS, images etc).
 */
export declare class FixedPageSaveOptionsData extends SaveOptionsData {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets a value determining how colors are rendered. { Normal | Grayscale}.
     */
    colorMode: string;
    /**
     * Gets or sets determines the quality of the JPEG images inside PDF document.
     */
    jpegQuality: number;
    /**
     * Gets or sets allows to specify metafile rendering options.
     */
    metafileRenderingOptions: MetafileRenderingOptionsData;
    /**
     * Gets or sets indicates the symbol set that is used to represent numbers while rendering to fixed page formats.
     */
    numeralFormat: string;
    /**
     * Gets or sets flag indicates whether it is required to optimize output of XPS. If this flag is set redundant nested canvases and empty canvases are removed, also neighbor glyphs with the same formatting are concatenated. Note: The accuracy of the content display may be affected if this property is set to true.  Default is false.
     */
    optimizeOutput: boolean;
    /**
     * Gets or sets determines number of pages to render.
     */
    pageCount: number;
    /**
     * Gets or sets determines 0-based index of the first page to render.
     */
    pageIndex: number;
    constructor(init?: Partial<FixedPageSaveOptionsData>);
}
/**
 * Font element.
 */
export declare class Font extends LinkElement {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets true if the font is formatted as all capital letters.
     */
    allCaps: boolean;
    /**
     * Gets or sets specifies whether the contents of this run shall have right-to-left characteristics.
     */
    bidi: boolean;
    /**
     * Gets or sets true if the font is formatted as bold.
     */
    bold: boolean;
    /**
     * Gets or sets true if the right-to-left text is formatted as bold.
     */
    boldBi: boolean;
    /**
     * Gets or sets border object that specifies border for the font.
     */
    border: Border;
    /**
     * Gets or sets the color of the font.
     */
    color: XmlColor;
    /**
     * Gets or sets specifies whether the contents of this run shall be treated as complex script text regardless of their Unicode character values when determining the formatting for this run.
     */
    complexScript: boolean;
    /**
     * Gets or sets true if the font is formatted as double strikethrough text.
     */
    doubleStrikeThrough: boolean;
    /**
     * Gets or sets true if the font is formatted as embossed.
     */
    emboss: boolean;
    /**
     * Gets or sets true if the font is formatted as engraved.
     */
    engrave: boolean;
    /**
     * Gets or sets true if the font is formatted as hidden text.
     */
    hidden: boolean;
    /**
     * Gets or sets the highlight (marker) color.
     */
    highlightColor: XmlColor;
    /**
     * Gets or sets true if the font is formatted as italic.
     */
    italic: boolean;
    /**
     * Gets or sets true if the right-to-left text is formatted as italic.
     */
    italicBi: boolean;
    /**
     * Gets or sets the font size at which kerning starts.
     */
    kerning: number;
    /**
     * Gets or sets the locale identifier (language) of the formatted characters.
     */
    localeId: number;
    /**
     * Gets or sets the locale identifier (language) of the formatted right-to-left characters.
     */
    localeIdBi: number;
    /**
     * Gets or sets the locale identifier (language) of the formatted Asian characters.
     */
    localeIdFarEast: number;
    /**
     * Gets or sets the name of the font.
     */
    name: string;
    /**
     * Gets or sets returns or sets the font used for Latin text (characters with character codes from 0 (zero) through 127).
     */
    nameAscii: string;
    /**
     * Gets or sets returns or sets the name of the font in a right-to-left language document.
     */
    nameBi: string;
    /**
     * Gets or sets returns or sets an East Asian font name.
     */
    nameFarEast: string;
    /**
     * Gets or sets returns or sets the font used for characters with character codes from 128 through 255.
     */
    nameOther: string;
    /**
     * Gets or sets true when the formatted characters are not to be spell checked.
     */
    noProofing: boolean;
    /**
     * Gets or sets true if the font is formatted as outline.
     */
    outline: boolean;
    /**
     * Gets or sets the position of text (in points) relative to the base line. A positive number raises the text, and a negative number lowers it.
     */
    position: number;
    /**
     * Gets or sets character width scaling in percent.
     */
    scaling: number;
    /**
     * Gets or sets true if the font is formatted as shadowed.
     */
    shadow: boolean;
    /**
     * Gets or sets the font size in points.
     */
    size: number;
    /**
     * Gets or sets the font size in points used in a right-to-left document.
     */
    sizeBi: number;
    /**
     * Gets or sets true if the font is formatted as small capital letters.
     */
    smallCaps: boolean;
    /**
     * Gets or sets returns or sets the spacing (in points) between characters.
     */
    spacing: number;
    /**
     * Gets or sets true if the font is formatted as strikethrough text.
     */
    strikeThrough: boolean;
    /**
     * Gets or sets the locale independent style identifier of the character style applied to this formatting.
     */
    styleIdentifier: Font.StyleIdentifierEnum;
    /**
     * Gets or sets the name of the character style applied to this formatting.
     */
    styleName: string;
    /**
     * Gets or sets true if the font is formatted as subscript.
     */
    subscript: boolean;
    /**
     * Gets or sets true if the font is formatted as superscript.
     */
    superscript: boolean;
    /**
     * Gets or sets the font animation effect.
     */
    textEffect: Font.TextEffectEnum;
    /**
     * Gets or sets the type of underline applied to the font.
     */
    underline: Font.UnderlineEnum;
    /**
     * Gets or sets the color of the underline applied to the font.
     */
    underlineColor: XmlColor;
    constructor(init?: Partial<Font>);
}
/**
 * Enums for Font
 */
export declare namespace Font {
    enum StyleIdentifierEnum {
        Normal,
        Heading1,
        Heading2,
        Heading3,
        Heading4,
        Heading5,
        Heading6,
        Heading7,
        Heading8,
        Heading9,
        Index1,
        Index2,
        Index3,
        Index4,
        Index5,
        Index6,
        Index7,
        Index8,
        Index9,
        Toc1,
        Toc2,
        Toc3,
        Toc4,
        Toc5,
        Toc6,
        Toc7,
        Toc8,
        Toc9,
        NormalIndent,
        FootnoteText,
        CommentText,
        Header,
        Footer,
        IndexHeading,
        Caption,
        TableOfFigures,
        EnvelopeAddress,
        EnvelopeReturn,
        FootnoteReference,
        CommentReference,
        LineNumber,
        PageNumber,
        EndnoteReference,
        EndnoteText,
        TableOfAuthorities,
        Macro,
        ToaHeading,
        List,
        ListBullet,
        ListNumber,
        List2,
        List3,
        List4,
        List5,
        ListBullet2,
        ListBullet3,
        ListBullet4,
        ListBullet5,
        ListNumber2,
        ListNumber3,
        ListNumber4,
        ListNumber5,
        Title,
        Closing,
        Signature,
        DefaultParagraphFont,
        BodyText,
        BodyTextInd,
        ListContinue,
        ListContinue2,
        ListContinue3,
        ListContinue4,
        ListContinue5,
        MessageHeader,
        Subtitle,
        Salutation,
        Date,
        BodyText1I,
        BodyText1I2,
        NoteHeading,
        BodyText2,
        BodyText3,
        BodyTextInd2,
        BodyTextInd3,
        BlockText,
        Hyperlink,
        FollowedHyperlink,
        Strong,
        Emphasis,
        DocumentMap,
        PlainText,
        EmailSignature,
        HtmlTopOfForm,
        HtmlBottomOfForm,
        NormalWeb,
        HtmlAcronym,
        HtmlAddress,
        HtmlCite,
        HtmlCode,
        HtmlDefinition,
        HtmlKeyboard,
        HtmlPreformatted,
        HtmlSample,
        HtmlTypewriter,
        HtmlVariable,
        TableNormal,
        CommentSubject,
        NoList,
        OutlineList1,
        OutlineList2,
        OutlineList3,
        TableSimple1,
        TableSimple2,
        TableSimple3,
        TableClassic1,
        TableClassic2,
        TableClassic3,
        TableClassic4,
        TableColorful1,
        TableColorful2,
        TableColorful3,
        TableColumns1,
        TableColumns2,
        TableColumns3,
        TableColumns4,
        TableColumns5,
        TableGrid1,
        TableGrid2,
        TableGrid3,
        TableGrid4,
        TableGrid5,
        TableGrid6,
        TableGrid7,
        TableGrid8,
        TableList1,
        TableList2,
        TableList3,
        TableList4,
        TableList5,
        TableList6,
        TableList7,
        TableList8,
        Table3DEffects1,
        Table3DEffects2,
        Table3DEffects3,
        TableContemporary,
        TableElegant,
        TableProfessional,
        TableSubtle1,
        TableSubtle2,
        TableWeb1,
        TableWeb2,
        TableWeb3,
        BalloonText,
        TableGrid,
        TableTheme,
        PlaceholderText,
        NoSpacing,
        LightShading,
        LightList,
        LightGrid,
        MediumShading1,
        MediumShading2,
        MediumList1,
        MediumList2,
        MediumGrid1,
        MediumGrid2,
        MediumGrid3,
        DarkList,
        ColorfulShading,
        ColorfulList,
        ColorfulGrid,
        LightShadingAccent1,
        LightListAccent1,
        LightGridAccent1,
        MediumShading1Accent1,
        MediumShading2Accent1,
        MediumList1Accent1,
        Revision,
        ListParagraph,
        Quote,
        IntenseQuote,
        MediumList2Accent1,
        MediumGrid1Accent1,
        MediumGrid2Accent1,
        MediumGrid3Accent1,
        DarkListAccent1,
        ColorfulShadingAccent1,
        ColorfulListAccent1,
        ColorfulGridAccent1,
        LightShadingAccent2,
        LightListAccent2,
        LightGridAccent2,
        MediumShading1Accent2,
        MediumShading2Accent2,
        MediumList1Accent2,
        MediumList2Accent2,
        MediumGrid1Accent2,
        MediumGrid2Accent2,
        MediumGrid3Accent2,
        DarkListAccent2,
        ColorfulShadingAccent2,
        ColorfulListAccent2,
        ColorfulGridAccent2,
        LightShadingAccent3,
        LightListAccent3,
        LightGridAccent3,
        MediumShading1Accent3,
        MediumShading2Accent3,
        MediumList1Accent3,
        MediumList2Accent3,
        MediumGrid1Accent3,
        MediumGrid2Accent3,
        MediumGrid3Accent3,
        DarkListAccent3,
        ColorfulShadingAccent3,
        ColorfulListAccent3,
        ColorfulGridAccent3,
        LightShadingAccent4,
        LightListAccent4,
        LightGridAccent4,
        MediumShading1Accent4,
        MediumShading2Accent4,
        MediumList1Accent4,
        MediumList2Accent4,
        MediumGrid1Accent4,
        MediumGrid2Accent4,
        MediumGrid3Accent4,
        DarkListAccent4,
        ColorfulShadingAccent4,
        ColorfulListAccent4,
        ColorfulGridAccent4,
        LightShadingAccent5,
        LightListAccent5,
        LightGridAccent5,
        MediumShading1Accent5,
        MediumShading2Accent5,
        MediumList1Accent5,
        MediumList2Accent5,
        MediumGrid1Accent5,
        MediumGrid2Accent5,
        MediumGrid3Accent5,
        DarkListAccent5,
        ColorfulShadingAccent5,
        ColorfulListAccent5,
        ColorfulGridAccent5,
        LightShadingAccent6,
        LightListAccent6,
        LightGridAccent6,
        MediumShading1Accent6,
        MediumShading2Accent6,
        MediumList1Accent6,
        MediumList2Accent6,
        MediumGrid1Accent6,
        MediumGrid2Accent6,
        MediumGrid3Accent6,
        DarkListAccent6,
        ColorfulShadingAccent6,
        ColorfulListAccent6,
        ColorfulGridAccent6,
        SubtleEmphasis,
        IntenseEmphasis,
        SubtleReference,
        IntenseReference,
        BookTitle,
        Bibliography,
        TocHeading,
        PlainTable1,
        PlainTable2,
        PlainTable3,
        PlainTable4,
        PlainTable5,
        TableGridLight,
        GridTable1Light,
        GridTable2,
        GridTable3,
        GridTable4,
        GridTable5Dark,
        GridTable6Colorful,
        GridTable7Colorful,
        GridTable1LightAccent1,
        GridTable2Accent1,
        GridTable3Accent1,
        GridTable4Accent1,
        GridTable5DarkAccent1,
        GridTable6ColorfulAccent1,
        GridTable7ColorfulAccent1,
        GridTable1LightAccent2,
        GridTable2Accent2,
        GridTable3Accent2,
        GridTable4Accent2,
        GridTable5DarkAccent2,
        GridTable6ColorfulAccent2,
        GridTable7ColorfulAccent2,
        GridTable1LightAccent3,
        GridTable2Accent3,
        GridTable3Accent3,
        GridTable4Accent3,
        GridTable5DarkAccent3,
        GridTable6ColorfulAccent3,
        GridTable7ColorfulAccent3,
        GridTable1LightAccent4,
        GridTable2Accent4,
        GridTable3Accent4,
        GridTable4Accent4,
        GridTable5DarkAccent4,
        GridTable6ColorfulAccent4,
        GridTable7ColorfulAccent4,
        GridTable1LightAccent5,
        GridTable2Accent5,
        GridTable3Accent5,
        GridTable4Accent5,
        GridTable5DarkAccent5,
        GridTable6ColorfulAccent5,
        GridTable7ColorfulAccent5,
        GridTable1LightAccent6,
        GridTable2Accent6,
        GridTable3Accent6,
        GridTable4Accent6,
        GridTable5DarkAccent6,
        GridTable6ColorfulAccent6,
        GridTable7ColorfulAccent6,
        ListTable1Light,
        ListTable2,
        ListTable3,
        ListTable4,
        ListTable5Dark,
        ListTable6Colorful,
        ListTable7Colorful,
        ListTable1LightAccent1,
        ListTable2Accent1,
        ListTable3Accent1,
        ListTable4Accent1,
        ListTable5DarkAccent1,
        ListTable6ColorfulAccent1,
        ListTable7ColorfulAccent1,
        ListTable1LightAccent2,
        ListTable2Accent2,
        ListTable3Accent2,
        ListTable4Accent2,
        ListTable5DarkAccent2,
        ListTable6ColorfulAccent2,
        ListTable7ColorfulAccent2,
        ListTable1LightAccent3,
        ListTable2Accent3,
        ListTable3Accent3,
        ListTable4Accent3,
        ListTable5DarkAccent3,
        ListTable6ColorfulAccent3,
        ListTable7ColorfulAccent3,
        ListTable1LightAccent4,
        ListTable2Accent4,
        ListTable3Accent4,
        ListTable4Accent4,
        ListTable5DarkAccent4,
        ListTable6ColorfulAccent4,
        ListTable7ColorfulAccent4,
        ListTable1LightAccent5,
        ListTable2Accent5,
        ListTable3Accent5,
        ListTable4Accent5,
        ListTable5DarkAccent5,
        ListTable6ColorfulAccent5,
        ListTable7ColorfulAccent5,
        ListTable1LightAccent6,
        ListTable2Accent6,
        ListTable3Accent6,
        ListTable4Accent6,
        ListTable5DarkAccent6,
        ListTable6ColorfulAccent6,
        ListTable7ColorfulAccent6,
        User,
        Nil
    }
    enum TextEffectEnum {
        None,
        LasVegasLights,
        BlinkingBackground,
        SparkleText,
        MarchingBlackAnts,
        MarchingRedAnts,
        Shimmer
    }
    enum UnderlineEnum {
        None,
        Single,
        Words,
        Double,
        Dotted,
        Thick,
        Dash,
        DotDash,
        DotDotDash,
        Wavy,
        DottedHeavy,
        DashHeavy,
        DotDashHeavy,
        DotDotDashHeavy,
        WavyHeavy,
        DashLong,
        WavyDouble,
        DashLongHeavy
    }
}
/**
 * This response should be returned by the service when handling: GET http://api.aspose.com/v4.0/words/Test.doc/paragraphs/{0}/runs/{1}/font.
 */
export declare class FontResponse extends WordsResponse {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets font.
     */
    font: Font;
    constructor(init?: Partial<FontResponse>);
}
/**
 * Collection of footnotes.
 */
export declare class FootnoteCollection extends LinkElement {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets collection of foonotes links.
     */
    list: Array<Footnote>;
    constructor(init?: Partial<FootnoteCollection>);
}
/**
 * This response should be returned by the service when handling: GET http://api.aspose.com/v4.0/words/Test.doc/footnote/0.
 */
export declare class FootnoteResponse extends WordsResponse {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets footnote information.
     */
    footnote: Footnote;
    constructor(init?: Partial<FootnoteResponse>);
}
/**
 * This response should be returned by the service when handling: GET http://api.aspose.com/v4.0/words/Test.doc/footnotes.
 */
export declare class FootnotesResponse extends WordsResponse {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets collection of footnotes.
     */
    footnotes: FootnoteCollection;
    constructor(init?: Partial<FootnotesResponse>);
}
/**
 * Represents DTO for collection of formfields.
 */
export declare class FormFieldCollection extends LinkElement {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets collection of formfields.
     */
    list: Array<FormField>;
    constructor(init?: Partial<FormFieldCollection>);
}
/**
 * This response should be returned by the service when handling: GET http://api.aspose.com/v4.0/words/Test.doc/paragraphs/{0}/formfields/{1}.
 */
export declare class FormFieldResponse extends WordsResponse {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets field information.
     */
    formField: FormField;
    constructor(init?: Partial<FormFieldResponse>);
}
/**
 * This response should be returned by the service when handling: GET http://api.aspose.com/v4.0/words/Test.doc/{nodePath}/formfields.
 */
export declare class FormFieldsResponse extends WordsResponse {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets collection of form fields.
     */
    formFields: FormFieldCollection;
    constructor(init?: Partial<FormFieldsResponse>);
}
/**
 * HeaderFooter link element.
 */
export declare class HeaderFooterLink extends LinkElement {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets paragraph's text.
     */
    type: HeaderFooterLink.TypeEnum;
    constructor(init?: Partial<HeaderFooterLink>);
}
/**
 * Enums for HeaderFooterLink
 */
export declare namespace HeaderFooterLink {
    enum TypeEnum {
        HeaderEven,
        HeaderPrimary,
        FooterEven,
        FooterPrimary,
        HeaderFirst,
        FooterFirst
    }
}
/**
 * Collection of links to header/footers.
 */
export declare class HeaderFooterLinkCollection extends LinkElement {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets collection of section's links.
     */
    list: Array<HeaderFooterLink>;
    constructor(init?: Partial<HeaderFooterLinkCollection>);
}
/**
 * This response should be returned by the service when handling: GET http://api.aspose.com/v4.0/words/Test.doc/headersfooters/{0}.
 */
export declare class HeaderFooterResponse extends WordsResponse {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets headerFooter.
     */
    headerFooter: HeaderFooter;
    constructor(init?: Partial<HeaderFooterResponse>);
}
/**
 * This response should be returned by the service when handling: GET http://api.aspose.com/v4.0/words/Test.doc/headersfooters.
 */
export declare class HeaderFootersResponse extends WordsResponse {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets collection of headers/footers.
     */
    headerFooters: HeaderFooterLinkCollection;
    constructor(init?: Partial<HeaderFootersResponse>);
}
/**
 * container class for html save options.
 */
export declare class HtmlSaveOptionsData extends SaveOptionsData {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets specifies whether negative left and right indents of paragraphs are allowed (not normalized).
     */
    allowNegativeIndent: boolean;
    /**
     * Gets or sets specifies a prefix which is added to all CSS class names. Default value is an empty string and generated CSS class names have no common prefix.  If this value is not empty, all CSS classes generated by Aspose.Words will start with the specified prefix.This might be useful, for example, if you add custom CSS to generated documents and want to prevent class name conflicts. If the value is not null or empty, it must be a valid CSS identifier.
     */
    cssClassNamePrefix: string;
    /**
     * Gets or sets specifies the name of the CSS file written when the document is exported to HTML.
     */
    cssStyleSheetFileName: string;
    /**
     * Gets or sets specifies how CSS styles are exported.
     */
    cssStyleSheetType: string;
    /**
     * Gets or sets specifies how the document should be split when saving.
     */
    documentSplitCriteria: string;
    /**
     * Gets or sets specifies the maximum level of headings at which to split the document.
     */
    documentSplitHeadingLevel: number;
    /**
     * Gets or sets specifies the encoding to use when exporting.
     */
    encoding: string;
    /**
     * Gets or sets specifies whether to export built-in and custom document properties.
     */
    exportDocumentProperties: boolean;
    /**
     * Gets or sets controls how drop-down form fields are saved to HTML. Default value is false.
     */
    exportDropDownFormFieldAsText: boolean;
    /**
     * Gets or sets specifies whether font resources should be exported.
     */
    exportFontResources: boolean;
    /**
     * Gets or sets specifies whether fonts resources should be embedded to HTML in Base64 encoding.  Default is false.
     */
    exportFontsAsBase64: boolean;
    /**
     * Gets or sets specifies how headers and footers are output.
     */
    exportHeadersFootersMode: string;
    /**
     * Gets or sets specifies whether images are saved in Base64 format.
     */
    exportImagesAsBase64: boolean;
    /**
     * Gets or sets specifies whether language information is exported.
     */
    exportLanguageInformation: boolean;
    /**
     * Gets or sets controls how list labels are output.
     */
    exportListLabels: string;
    /**
     * Gets or sets specifies whether original URL should be used as the URL of the linked images. Default value is false.
     */
    exportOriginalUrlForLinkedImages: boolean;
    /**
     * Gets or sets specifies whether page margins is exported to HTML, MHTML or EPUB. Default is false.
     */
    exportPageMargins: boolean;
    /**
     * Gets or sets specifies whether page setup is exported.
     */
    exportPageSetup: boolean;
    /**
     * Gets or sets specifies whether font sizes should be output in relative units when saving.
     */
    exportRelativeFontSize: boolean;
    /**
     * Gets or sets specifies whether to write the roundtrip information when saving to HTML Default value is true.
     */
    exportRoundtripInformation: boolean;
    /**
     * Gets or sets controls how textboxes represented by Aspose.Words.Drawing.Shape are saved to HTML, MHTML or EPUB. Default value is false.    When set to true, exports textboxes as inline \"svg\" elements. When false, exports as \"image\" elements.
     */
    exportTextBoxAsSvg: boolean;
    /**
     * Gets or sets controls how text input form fields are saved.
     */
    exportTextInputFormFieldAsText: boolean;
    /**
     * Gets or sets specifies whether to write page numbers to table of contents when saving.
     */
    exportTocPageNumbers: boolean;
    /**
     * Gets or sets specifies whether to write the DOCTYPE declaration when saving.
     */
    exportXhtmlTransitional: boolean;
    /**
     * Gets or sets controls which font resources need subsetting when saving.
     */
    fontResourcesSubsettingSizeThreshold: number;
    /**
     * Gets or sets specifies the physical folder where fonts are saved when exporting a document.
     */
    fontsFolder: string;
    /**
     * Gets or sets specifies the name of the folder used to construct font URIs.
     */
    fontsFolderAlias: string;
    /**
     * Gets or sets specifies version of HTML standard that should be used when saving the document to HTML or MHTML. Default value is Aspose.Words.Saving.HtmlVersion.Xhtml.
     */
    htmlVersion: HtmlSaveOptionsData.HtmlVersionEnum;
    /**
     * Gets or sets specifies the output resolution for images when exporting.
     */
    imageResolution: number;
    /**
     * Gets or sets specifies the physical folder where images are saved when exporting a document.
     */
    imagesFolder: string;
    /**
     * Gets or sets specifies the name of the folder used to construct image URIs.
     */
    imagesFolderAlias: string;
    /**
     * Gets or sets specifies in what format metafiles are saved when exporting to HTML, MHTML, or EPUB. Default value is Aspose.Words.Saving.HtmlMetafileFormat.Png, meaning that metafiles are rendered to raster PNG images.  Metafiles are not natively displayed by HTML browsers. By default, Aspose.Words converts WMF and EMF images into PNG files when exporting to HTML.Other options are to convert metafiles to SVG images or to export them as is without conversion. Some image transforms, in particular image cropping, will not be applied to metafile images if they are exported to HTML without conversion.
     */
    metafileFormat: HtmlSaveOptionsData.MetafileFormatEnum;
    /**
     * Gets or sets controls how OfficeMath objects are exported to HTML, MHTML or EPUB.  Default value is HtmlOfficeMathOutputMode.Image.
     */
    officeMathOutputMode: HtmlSaveOptionsData.OfficeMathOutputModeEnum;
    /**
     * Gets or sets specifies whether or not use pretty formats output.
     */
    prettyFormat: boolean;
    /**
     * Gets or sets specifies whether font family names used in the document are resolved and substituted according to FontSettings when being written into HTML-based formats. default value is false.
     */
    resolveFontNames: boolean;
    /**
     * Gets or sets specifies a physical folder where all resources like images, fonts, and external CSS are saved when a document is exported to HTML. Default is an empty string.
     */
    resourceFolder: string;
    /**
     * Gets or sets specifies the name of the folder used to construct URIs of all resources written into an HTML document.  Default is an empty string.
     */
    resourceFolderAlias: string;
    /**
     * Gets or sets specifies whether images are scaled by Aspose.Words to the bounding shape size when exporting.
     */
    scaleImageToShapeSize: boolean;
    /**
     * Gets or sets controls how table, row and cell widths are exported.
     */
    tableWidthOutputMode: string;
    constructor(init?: Partial<HtmlSaveOptionsData>);
}
/**
 * Enums for HtmlSaveOptionsData
 */
export declare namespace HtmlSaveOptionsData {
    enum HtmlVersionEnum {
        Xhtml,
        Html5
    }
    enum MetafileFormatEnum {
        Png,
        Svg,
        EmfOrWmf
    }
    enum OfficeMathOutputModeEnum {
        Image,
        MathML,
        Text
    }
}
/**
 * Hyperlink element.
 */
export declare class Hyperlink extends LinkElement {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets hypelink's display text.
     */
    displayText: string;
    /**
     * Gets or sets value.
     */
    value: string;
    constructor(init?: Partial<Hyperlink>);
}
/**
 * This response should be returned by the service when handling:  GET /{name}/hyperlinks/{hyperlinkIndex} .
 */
export declare class HyperlinkResponse extends WordsResponse {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets hyperlink.
     */
    hyperlink: Hyperlink;
    constructor(init?: Partial<HyperlinkResponse>);
}
/**
 * Collection of .
 */
export declare class Hyperlinks extends LinkElement {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets array of .
     */
    hyperlinkList: Array<Hyperlink>;
    constructor(init?: Partial<Hyperlinks>);
}
/**
 * This response should be returned by the service when handling:  GET /{name}/hyperlinks .
 */
export declare class HyperlinksResponse extends WordsResponse {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets collection of hyperlinks.
     */
    hyperlinks: Hyperlinks;
    constructor(init?: Partial<HyperlinksResponse>);
}
/**
 * Reference to node.
 */
export declare class NodeLink extends LinkElement {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets node id.
     */
    nodeId: string;
    constructor(init?: Partial<NodeLink>);
}
/**
 * container class for odt/ott save options.
 */
export declare class OdtSaveOptionsData extends SaveOptionsData {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets specifies whether export should correspond to ODT specification 1.1 strictly.
     */
    isStrictSchema11: boolean;
    /**
     * Gets or sets allows to specify units of measure to apply to document content. The default value is Aspose.Words.Saving.OdtSaveMeasureUnit.Centimeters.  Open Office uses centimeters when specifying lengths, widths and other measurable formatting and content properties in documents whereas MS Office uses inches.
     */
    measureUnit: OdtSaveOptionsData.MeasureUnitEnum;
    /**
     * Gets or sets specifies whether or not use pretty formats output.
     */
    prettyFormat: boolean;
    constructor(init?: Partial<OdtSaveOptionsData>);
}
/**
 * Enums for OdtSaveOptionsData
 */
export declare namespace OdtSaveOptionsData {
    enum MeasureUnitEnum {
        Centimeters,
        Inches
    }
}
/**
 * This response should be returned by the service when handling: GET http://api.aspose.com/v4.0/words/Test.doc/officeMathObjects/0.
 */
export declare class OfficeMathObjectResponse extends WordsResponse {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets officeMathObject information.
     */
    officeMathObject: OfficeMathObject;
    constructor(init?: Partial<OfficeMathObjectResponse>);
}
/**
 * Collection of OfficeMath objects.
 */
export declare class OfficeMathObjectsCollection extends LinkElement {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets collection of OfficeMath objects.
     */
    list: Array<OfficeMathObject>;
    constructor(init?: Partial<OfficeMathObjectsCollection>);
}
/**
 * This response should be returned by the service when handling: GET http://api.aspose.com/v4.0/words/Test.doc/OfficeMathObjects.
 */
export declare class OfficeMathObjectsResponse extends WordsResponse {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets collection of OfficeMath objects.
     */
    officeMathObjects: OfficeMathObjectsCollection;
    constructor(init?: Partial<OfficeMathObjectsResponse>);
}
/**
 * container class for docx/docm/dotx/dotm/flatopc save options.
 */
export declare class OoxmlSaveOptionsData extends SaveOptionsData {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets specifies the OOXML version for the output document.
     */
    compliance: string;
    /**
     * Gets or sets specifies a password to encrypt document using ECMA376 Standard encryption algorithm.
     */
    password: string;
    /**
     * Gets or sets specifies whether or not use pretty formats output.
     */
    prettyFormat: boolean;
    constructor(init?: Partial<OoxmlSaveOptionsData>);
}
/**
 * Represents the page setup properties of a section.
 */
export declare class PageSetup extends LinkElement {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets specifies that this section contains bidirectional (complex scripts) text.
     */
    bidi: boolean;
    /**
     * Gets or sets specifies where the page border is positioned relative to intersecting texts and objects.
     */
    borderAlwaysInFront: boolean;
    /**
     * Gets or sets specifies which pages the page border is printed on.
     */
    borderAppliesTo: PageSetup.BorderAppliesToEnum;
    /**
     * Gets or sets a value that indicates whether the specified page border is measured from the edge of the page or from the text it surrounds.
     */
    borderDistanceFrom: PageSetup.BorderDistanceFromEnum;
    /**
     * Gets or sets returns or sets the distance (in points) between the bottom edge of the page and the bottom boundary of the body text.
     */
    bottomMargin: number;
    /**
     * Gets or sets true if a different header or footer is used on the first page.
     */
    differentFirstPageHeaderFooter: boolean;
    /**
     * Gets or sets the paper tray (bin) to use for the first page of a section. The value is implementation (printer) specific.
     */
    firstPageTray: number;
    /**
     * Gets or sets returns or sets the distance (in points) between the footer and the bottom of the page.
     */
    footerDistance: number;
    /**
     * Gets or sets the amount of extra space added to the margin for document binding.
     */
    gutter: number;
    /**
     * Gets or sets returns or sets the distance (in points) between the header and the top of the page.
     */
    headerDistance: number;
    /**
     * Gets or sets returns or sets the distance (in points) between the left edge of the page and the left boundary of the body text.
     */
    leftMargin: number;
    /**
     * Gets or sets returns or sets the numeric increment for line numbers.
     */
    lineNumberCountBy: number;
    /**
     * Gets or sets distance between the right edge of line numbers and the left edge of the document.
     */
    lineNumberDistanceFromText: number;
    /**
     * Gets or sets the way line numbering runs  that is, whether it starts over at the beginning of a new page or section or runs continuously.
     */
    lineNumberRestartMode: PageSetup.LineNumberRestartModeEnum;
    /**
     * Gets or sets the starting line number.
     */
    lineStartingNumber: number;
    /**
     * Gets or sets returns or sets the orientation of the page.
     */
    orientation: PageSetup.OrientationEnum;
    /**
     * Gets or sets the paper tray (bin) to be used for all but the first page of a section. The value is implementation (printer) specific.
     */
    otherPagesTray: number;
    /**
     * Gets or sets returns or sets the height of the page in points.
     */
    pageHeight: number;
    /**
     * Gets or sets the page number format.
     */
    pageNumberStyle: PageSetup.PageNumberStyleEnum;
    /**
     * Gets or sets the starting page number of the section.
     */
    pageStartingNumber: number;
    /**
     * Gets or sets returns or sets the width of the page in points.
     */
    pageWidth: number;
    /**
     * Gets or sets returns or sets the paper size.
     */
    paperSize: PageSetup.PaperSizeEnum;
    /**
     * Gets or sets true if page numbering restarts at the beginning of the section.
     */
    restartPageNumbering: boolean;
    /**
     * Gets or sets returns or sets the distance (in points) between the right edge of the page and the right boundary of the body text.
     */
    rightMargin: number;
    /**
     * Gets or sets whether Microsoft Word uses gutters for the section based on a right-to-left language or a left-to-right language.
     */
    rtlGutter: boolean;
    /**
     * Gets or sets returns or sets the type of section break for the specified object.
     */
    sectionStart: PageSetup.SectionStartEnum;
    /**
     * Gets or sets true if endnotes are printed at the end of the next section that doesn't suppress endnotes.                 Suppressed endnotes are printed before the endnotes in that section.
     */
    suppressEndnotes: boolean;
    /**
     * Gets or sets returns or sets the distance (in points) between the top edge of the page and the top boundary of the body text.
     */
    topMargin: number;
    /**
     * Gets or sets returns or sets the vertical alignment of text on each page in a document or section.
     */
    verticalAlignment: PageSetup.VerticalAlignmentEnum;
    constructor(init?: Partial<PageSetup>);
}
/**
 * Enums for PageSetup
 */
export declare namespace PageSetup {
    enum BorderAppliesToEnum {
        AllPages,
        FirstPage,
        OtherPages
    }
    enum BorderDistanceFromEnum {
        Text,
        PageEdge
    }
    enum LineNumberRestartModeEnum {
        RestartPage,
        RestartSection,
        Continuous
    }
    enum OrientationEnum {
        Portrait,
        Landscape
    }
    enum PageNumberStyleEnum {
        Arabic,
        UppercaseRoman,
        LowercaseRoman,
        UppercaseLetter,
        LowercaseLetter,
        Ordinal,
        Number,
        OrdinalText,
        Hex,
        ChicagoManual,
        Kanji,
        KanjiDigit,
        AiueoHalfWidth,
        IrohaHalfWidth,
        ArabicFullWidth,
        ArabicHalfWidth,
        KanjiTraditional,
        KanjiTraditional2,
        NumberInCircle,
        DecimalFullWidth,
        Aiueo,
        Iroha,
        LeadingZero,
        Bullet,
        Ganada,
        Chosung,
        GB1,
        GB2,
        GB3,
        GB4,
        Zodiac1,
        Zodiac2,
        Zodiac3,
        TradChinNum1,
        TradChinNum2,
        TradChinNum3,
        TradChinNum4,
        SimpChinNum1,
        SimpChinNum2,
        SimpChinNum3,
        SimpChinNum4,
        HanjaRead,
        HanjaReadDigit,
        Hangul,
        Hanja,
        Hebrew1,
        Arabic1,
        Hebrew2,
        Arabic2,
        HindiLetter1,
        HindiLetter2,
        HindiArabic,
        HindiCardinalText,
        ThaiLetter,
        ThaiArabic,
        ThaiCardinalText,
        VietCardinalText,
        NumberInDash,
        LowercaseRussian,
        UppercaseRussian,
        None,
        Custom
    }
    enum PaperSizeEnum {
        A3,
        A4,
        A5,
        B4,
        B5,
        Executive,
        Folio,
        Ledger,
        Legal,
        Letter,
        EnvelopeDL,
        Quarto,
        Statement,
        Tabloid,
        Paper10x14,
        Paper11x17,
        Custom
    }
    enum SectionStartEnum {
        Continuous,
        NewColumn,
        NewPage,
        EvenPage,
        OddPage
    }
    enum VerticalAlignmentEnum {
        Top,
        Center,
        Justify,
        Bottom
    }
}
/**
 * Paragraph format element.
 */
export declare class ParagraphFormat extends LinkElement {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets a flag indicating whether inter-character spacing is automatically adjusted between regions of Latin text and regions of East Asian text in the current paragraph.
     */
    addSpaceBetweenFarEastAndAlpha: boolean;
    /**
     * Gets or sets a flag indicating whether inter-character spacing is automatically adjusted between regions of numbers and regions of East Asian text in the current paragraph.
     */
    addSpaceBetweenFarEastAndDigit: boolean;
    /**
     * Gets or sets text alignment for the paragraph.
     */
    alignment: ParagraphFormat.AlignmentEnum;
    /**
     * Gets or sets whether this is a right-to-left paragraph.
     */
    bidi: boolean;
    /**
     * Gets or sets the position for a drop cap text.
     */
    dropCapPosition: ParagraphFormat.DropCapPositionEnum;
    /**
     * Gets or sets the value (in points) for a first line or hanging indent. Use a positive value to set a first-line indent, and use a negative value to set a hanging indent.
     */
    firstLineIndent: number;
    /**
     * Gets or sets True when the paragraph is an item in a bulleted or numbered list.
     */
    isListItem: boolean;
    /**
     * Gets or sets true if all lines in the paragraph are to remain on the same page.
     */
    keepTogether: boolean;
    /**
     * Gets or sets true if the paragraph is to remains on the same page as the paragraph that follows it.
     */
    keepWithNext: boolean;
    /**
     * Gets or sets the value (in points) that represents the left indent for paragraph.
     */
    leftIndent: number;
    /**
     * Gets or sets the line spacing (in points) for the paragraph.
     */
    lineSpacing: number;
    /**
     * Gets or sets the line spacing for the paragraph.
     */
    lineSpacingRule: ParagraphFormat.LineSpacingRuleEnum;
    /**
     * Gets or sets the number of lines of the paragraph text used to calculate the drop cap height.
     */
    linesToDrop: number;
    /**
     * Gets or sets when true,  and  will be ignored between the paragraphs of the same style.
     */
    noSpaceBetweenParagraphsOfSameStyle: boolean;
    /**
     * Gets or sets specifies the outline level of the paragraph in the document.
     */
    outlineLevel: ParagraphFormat.OutlineLevelEnum;
    /**
     * Gets or sets true if a page break is forced before the paragraph.
     */
    pageBreakBefore: boolean;
    /**
     * Gets or sets the value (in points) that represents the right indent for paragraph.
     */
    rightIndent: number;
    /**
     * Gets or sets the amount of spacing (in points) after the paragraph.
     */
    spaceAfter: number;
    /**
     * Gets or sets true if the amount of spacing after the paragraph is set automatically.
     */
    spaceAfterAuto: boolean;
    /**
     * Gets or sets the amount of spacing (in points) before the paragraph.
     */
    spaceBefore: number;
    /**
     * Gets or sets true if the amount of spacing before the paragraph is set automatically.
     */
    spaceBeforeAuto: boolean;
    /**
     * Gets or sets the locale independent style identifier of the paragraph style applied to this formatting.
     */
    styleIdentifier: ParagraphFormat.StyleIdentifierEnum;
    /**
     * Gets or sets the name of the paragraph style applied to this formatting.
     */
    styleName: string;
    /**
     * Gets or sets specifies whether the current paragraph should be exempted from any hyphenation which is applied in the document settings.
     */
    suppressAutoHyphens: boolean;
    /**
     * Gets or sets specifies whether the current paragraph's lines should be exempted from line numbering which is applied in the parent section.
     */
    suppressLineNumbers: boolean;
    /**
     * Gets or sets true if the first and last lines in the paragraph are to remain on the same page as the rest of the paragraph.
     */
    widowControl: boolean;
    constructor(init?: Partial<ParagraphFormat>);
}
/**
 * Enums for ParagraphFormat
 */
export declare namespace ParagraphFormat {
    enum AlignmentEnum {
        Left,
        Center,
        Right,
        Justify,
        Distributed,
        ArabicMediumKashida,
        ArabicHighKashida,
        ArabicLowKashida,
        ThaiDistributed
    }
    enum DropCapPositionEnum {
        None,
        Normal,
        Margin
    }
    enum LineSpacingRuleEnum {
        AtLeast,
        Exactly,
        Multiple
    }
    enum OutlineLevelEnum {
        Level1,
        Level2,
        Level3,
        Level4,
        Level5,
        Level6,
        Level7,
        Level8,
        Level9,
        BodyText
    }
    enum StyleIdentifierEnum {
        Normal,
        Heading1,
        Heading2,
        Heading3,
        Heading4,
        Heading5,
        Heading6,
        Heading7,
        Heading8,
        Heading9,
        Index1,
        Index2,
        Index3,
        Index4,
        Index5,
        Index6,
        Index7,
        Index8,
        Index9,
        Toc1,
        Toc2,
        Toc3,
        Toc4,
        Toc5,
        Toc6,
        Toc7,
        Toc8,
        Toc9,
        NormalIndent,
        FootnoteText,
        CommentText,
        Header,
        Footer,
        IndexHeading,
        Caption,
        TableOfFigures,
        EnvelopeAddress,
        EnvelopeReturn,
        FootnoteReference,
        CommentReference,
        LineNumber,
        PageNumber,
        EndnoteReference,
        EndnoteText,
        TableOfAuthorities,
        Macro,
        ToaHeading,
        List,
        ListBullet,
        ListNumber,
        List2,
        List3,
        List4,
        List5,
        ListBullet2,
        ListBullet3,
        ListBullet4,
        ListBullet5,
        ListNumber2,
        ListNumber3,
        ListNumber4,
        ListNumber5,
        Title,
        Closing,
        Signature,
        DefaultParagraphFont,
        BodyText,
        BodyTextInd,
        ListContinue,
        ListContinue2,
        ListContinue3,
        ListContinue4,
        ListContinue5,
        MessageHeader,
        Subtitle,
        Salutation,
        Date,
        BodyText1I,
        BodyText1I2,
        NoteHeading,
        BodyText2,
        BodyText3,
        BodyTextInd2,
        BodyTextInd3,
        BlockText,
        Hyperlink,
        FollowedHyperlink,
        Strong,
        Emphasis,
        DocumentMap,
        PlainText,
        EmailSignature,
        HtmlTopOfForm,
        HtmlBottomOfForm,
        NormalWeb,
        HtmlAcronym,
        HtmlAddress,
        HtmlCite,
        HtmlCode,
        HtmlDefinition,
        HtmlKeyboard,
        HtmlPreformatted,
        HtmlSample,
        HtmlTypewriter,
        HtmlVariable,
        TableNormal,
        CommentSubject,
        NoList,
        OutlineList1,
        OutlineList2,
        OutlineList3,
        TableSimple1,
        TableSimple2,
        TableSimple3,
        TableClassic1,
        TableClassic2,
        TableClassic3,
        TableClassic4,
        TableColorful1,
        TableColorful2,
        TableColorful3,
        TableColumns1,
        TableColumns2,
        TableColumns3,
        TableColumns4,
        TableColumns5,
        TableGrid1,
        TableGrid2,
        TableGrid3,
        TableGrid4,
        TableGrid5,
        TableGrid6,
        TableGrid7,
        TableGrid8,
        TableList1,
        TableList2,
        TableList3,
        TableList4,
        TableList5,
        TableList6,
        TableList7,
        TableList8,
        Table3DEffects1,
        Table3DEffects2,
        Table3DEffects3,
        TableContemporary,
        TableElegant,
        TableProfessional,
        TableSubtle1,
        TableSubtle2,
        TableWeb1,
        TableWeb2,
        TableWeb3,
        BalloonText,
        TableGrid,
        TableTheme,
        PlaceholderText,
        NoSpacing,
        LightShading,
        LightList,
        LightGrid,
        MediumShading1,
        MediumShading2,
        MediumList1,
        MediumList2,
        MediumGrid1,
        MediumGrid2,
        MediumGrid3,
        DarkList,
        ColorfulShading,
        ColorfulList,
        ColorfulGrid,
        LightShadingAccent1,
        LightListAccent1,
        LightGridAccent1,
        MediumShading1Accent1,
        MediumShading2Accent1,
        MediumList1Accent1,
        Revision,
        ListParagraph,
        Quote,
        IntenseQuote,
        MediumList2Accent1,
        MediumGrid1Accent1,
        MediumGrid2Accent1,
        MediumGrid3Accent1,
        DarkListAccent1,
        ColorfulShadingAccent1,
        ColorfulListAccent1,
        ColorfulGridAccent1,
        LightShadingAccent2,
        LightListAccent2,
        LightGridAccent2,
        MediumShading1Accent2,
        MediumShading2Accent2,
        MediumList1Accent2,
        MediumList2Accent2,
        MediumGrid1Accent2,
        MediumGrid2Accent2,
        MediumGrid3Accent2,
        DarkListAccent2,
        ColorfulShadingAccent2,
        ColorfulListAccent2,
        ColorfulGridAccent2,
        LightShadingAccent3,
        LightListAccent3,
        LightGridAccent3,
        MediumShading1Accent3,
        MediumShading2Accent3,
        MediumList1Accent3,
        MediumList2Accent3,
        MediumGrid1Accent3,
        MediumGrid2Accent3,
        MediumGrid3Accent3,
        DarkListAccent3,
        ColorfulShadingAccent3,
        ColorfulListAccent3,
        ColorfulGridAccent3,
        LightShadingAccent4,
        LightListAccent4,
        LightGridAccent4,
        MediumShading1Accent4,
        MediumShading2Accent4,
        MediumList1Accent4,
        MediumList2Accent4,
        MediumGrid1Accent4,
        MediumGrid2Accent4,
        MediumGrid3Accent4,
        DarkListAccent4,
        ColorfulShadingAccent4,
        ColorfulListAccent4,
        ColorfulGridAccent4,
        LightShadingAccent5,
        LightListAccent5,
        LightGridAccent5,
        MediumShading1Accent5,
        MediumShading2Accent5,
        MediumList1Accent5,
        MediumList2Accent5,
        MediumGrid1Accent5,
        MediumGrid2Accent5,
        MediumGrid3Accent5,
        DarkListAccent5,
        ColorfulShadingAccent5,
        ColorfulListAccent5,
        ColorfulGridAccent5,
        LightShadingAccent6,
        LightListAccent6,
        LightGridAccent6,
        MediumShading1Accent6,
        MediumShading2Accent6,
        MediumList1Accent6,
        MediumList2Accent6,
        MediumGrid1Accent6,
        MediumGrid2Accent6,
        MediumGrid3Accent6,
        DarkListAccent6,
        ColorfulShadingAccent6,
        ColorfulListAccent6,
        ColorfulGridAccent6,
        SubtleEmphasis,
        IntenseEmphasis,
        SubtleReference,
        IntenseReference,
        BookTitle,
        Bibliography,
        TocHeading,
        PlainTable1,
        PlainTable2,
        PlainTable3,
        PlainTable4,
        PlainTable5,
        TableGridLight,
        GridTable1Light,
        GridTable2,
        GridTable3,
        GridTable4,
        GridTable5Dark,
        GridTable6Colorful,
        GridTable7Colorful,
        GridTable1LightAccent1,
        GridTable2Accent1,
        GridTable3Accent1,
        GridTable4Accent1,
        GridTable5DarkAccent1,
        GridTable6ColorfulAccent1,
        GridTable7ColorfulAccent1,
        GridTable1LightAccent2,
        GridTable2Accent2,
        GridTable3Accent2,
        GridTable4Accent2,
        GridTable5DarkAccent2,
        GridTable6ColorfulAccent2,
        GridTable7ColorfulAccent2,
        GridTable1LightAccent3,
        GridTable2Accent3,
        GridTable3Accent3,
        GridTable4Accent3,
        GridTable5DarkAccent3,
        GridTable6ColorfulAccent3,
        GridTable7ColorfulAccent3,
        GridTable1LightAccent4,
        GridTable2Accent4,
        GridTable3Accent4,
        GridTable4Accent4,
        GridTable5DarkAccent4,
        GridTable6ColorfulAccent4,
        GridTable7ColorfulAccent4,
        GridTable1LightAccent5,
        GridTable2Accent5,
        GridTable3Accent5,
        GridTable4Accent5,
        GridTable5DarkAccent5,
        GridTable6ColorfulAccent5,
        GridTable7ColorfulAccent5,
        GridTable1LightAccent6,
        GridTable2Accent6,
        GridTable3Accent6,
        GridTable4Accent6,
        GridTable5DarkAccent6,
        GridTable6ColorfulAccent6,
        GridTable7ColorfulAccent6,
        ListTable1Light,
        ListTable2,
        ListTable3,
        ListTable4,
        ListTable5Dark,
        ListTable6Colorful,
        ListTable7Colorful,
        ListTable1LightAccent1,
        ListTable2Accent1,
        ListTable3Accent1,
        ListTable4Accent1,
        ListTable5DarkAccent1,
        ListTable6ColorfulAccent1,
        ListTable7ColorfulAccent1,
        ListTable1LightAccent2,
        ListTable2Accent2,
        ListTable3Accent2,
        ListTable4Accent2,
        ListTable5DarkAccent2,
        ListTable6ColorfulAccent2,
        ListTable7ColorfulAccent2,
        ListTable1LightAccent3,
        ListTable2Accent3,
        ListTable3Accent3,
        ListTable4Accent3,
        ListTable5DarkAccent3,
        ListTable6ColorfulAccent3,
        ListTable7ColorfulAccent3,
        ListTable1LightAccent4,
        ListTable2Accent4,
        ListTable3Accent4,
        ListTable4Accent4,
        ListTable5DarkAccent4,
        ListTable6ColorfulAccent4,
        ListTable7ColorfulAccent4,
        ListTable1LightAccent5,
        ListTable2Accent5,
        ListTable3Accent5,
        ListTable4Accent5,
        ListTable5DarkAccent5,
        ListTable6ColorfulAccent5,
        ListTable7ColorfulAccent5,
        ListTable1LightAccent6,
        ListTable2Accent6,
        ListTable3Accent6,
        ListTable4Accent6,
        ListTable5DarkAccent6,
        ListTable6ColorfulAccent6,
        ListTable7ColorfulAccent6,
        User,
        Nil
    }
}
/**
 * This response should be returned by the service when handling: GET http://api.aspose.com/v4.0/words/Test.doc/paragraphs/{0}/format.
 */
export declare class ParagraphFormatResponse extends WordsResponse {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets represents all the formatting for a paragraph.
     */
    paragraphFormat: ParagraphFormat;
    constructor(init?: Partial<ParagraphFormatResponse>);
}
/**
 * Collection of links to paragraphs.
 */
export declare class ParagraphLinkCollection extends LinkElement {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets collection of paragraph's links.
     */
    paragraphLinkList: Array<ParagraphLink>;
    constructor(init?: Partial<ParagraphLinkCollection>);
}
/**
 * This response should be returned by the service when handling: GET http://api.aspose.com/v4.0/words/Test.doc/paragraphs.
 */
export declare class ParagraphLinkCollectionResponse extends WordsResponse {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets collection of paragraphs.
     */
    paragraphs: ParagraphLinkCollection;
    constructor(init?: Partial<ParagraphLinkCollectionResponse>);
}
/**
 * This response should be returned by the service when handling: GET http://api.aspose.com/v4.0/words/Test.doc/paragraphs/{0}.
 */
export declare class ParagraphResponse extends WordsResponse {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets paragraph.
     */
    paragraph: Paragraph;
    constructor(init?: Partial<ParagraphResponse>);
}
/**
 * Response for the request of data about protection.
 */
export declare class ProtectionDataResponse extends WordsResponse {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets link to the document.
     */
    documentLink: FileLink;
    /**
     * Gets or sets protection's data of the document.
     */
    protectionData: ProtectionData;
    constructor(init?: Partial<ProtectionDataResponse>);
}
/**
 * This response should be returned by the service when handling: GET http://api.aspose.com/v4.0/words/Test.doc/range/{0}/{1}/.
 */
export declare class RangeTextResponse extends WordsResponse {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets text from range.
     */
    text: string;
    constructor(init?: Partial<RangeTextResponse>);
}
/**
 * Response for \"Replace text\" action.
 */
export declare class ReplaceTextResponse extends WordsResponse {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets link to the document.
     */
    documentLink: FileLink;
    /**
     * Gets or sets number of occurrences of the captured text in the document.
     */
    matches: number;
    constructor(init?: Partial<ReplaceTextResponse>);
}
/**
 * response of the modification operations for the revisions collection (now these are acceptAll and rejectAll).
 */
export declare class RevisionsModificationResponse extends WordsResponse {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets result of the modification operations for the revisions collection.
     */
    result: ModificationOperationResult;
    constructor(init?: Partial<RevisionsModificationResponse>);
}
/**
 * container class for rtf save options.
 */
export declare class RtfSaveOptionsData extends SaveOptionsData {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets allows to make output RTF documents smaller in size, but if they contain RTL (right-to-left) text, it will not be displayed correctly.
     */
    exportCompactSize: boolean;
    /**
     * Gets or sets specifies whether the keywords for \"old readers\" are written to RTF or not.
     */
    exportImagesForOldReaders: boolean;
    /**
     * Gets or sets specifies whether or not use pretty formats output.
     */
    prettyFormat: boolean;
    constructor(init?: Partial<RtfSaveOptionsData>);
}
/**
 * This response should be returned by the service when handling: GET http://api.aspose.com/v4.0/words/Test.doc/paragraphs/{0}/runs/{1}.
 */
export declare class RunResponse extends WordsResponse {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets run.
     */
    run: Run;
    constructor(init?: Partial<RunResponse>);
}
/**
 * Represents DTO for collection of runs.
 */
export declare class Runs extends LinkElement {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets collection of fields.
     */
    list: Array<Run>;
    constructor(init?: Partial<Runs>);
}
/**
 * This response should be returned by the service when handling: GET http://api.aspose.com/v4.0/words/Test.doc/{paragraphPath}/runs.
 */
export declare class RunsResponse extends WordsResponse {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets collection of runs.
     */
    runs: Runs;
    constructor(init?: Partial<RunsResponse>);
}
/**
 * Save response.
 */
export declare class SaveResponse extends WordsResponse {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets save result.
     */
    saveResult: SaveResult;
    constructor(init?: Partial<SaveResponse>);
}
/**
 * This response should be returned by the service when handling: GET http://api.aspose.com/v4.0/words/Test.doc/search.
 */
export declare class SearchResponse extends WordsResponse {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets a regular expression pattern used to find matches.
     */
    searchingPattern: string;
    /**
     * Gets or sets collection of search results.
     */
    searchResults: SearchResultsCollection;
    constructor(init?: Partial<SearchResponse>);
}
/**
 * Collection of search results.
 */
export declare class SearchResultsCollection extends LinkElement {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets collection of comments.
     */
    resultsList: Array<SearchResult>;
    constructor(init?: Partial<SearchResultsCollection>);
}
/**
 * Section element.
 */
export declare class Section extends LinkElement {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets child nodes.
     */
    childNodes: Array<NodeLink>;
    /**
     * Gets or sets link to HeaderFooters resource.
     */
    headerFooters: LinkElement;
    /**
     * Gets or sets link to PageSetup resource.
     */
    pageSetup: LinkElement;
    /**
     * Gets or sets link to Paragraphs resource.
     */
    paragraphs: LinkElement;
    /**
     * Gets or sets link to Tables resource.
     */
    tables: LinkElement;
    constructor(init?: Partial<Section>);
}
/**
 * Collection of links to sections.
 */
export declare class SectionLinkCollection extends LinkElement {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets collection of section's links.
     */
    sectionLinkList: Array<SectionLink>;
    constructor(init?: Partial<SectionLinkCollection>);
}
/**
 * This response should be returned by the service when handling: GET http://api.aspose.com/v4.0/words/Test.doc/sections.
 */
export declare class SectionLinkCollectionResponse extends WordsResponse {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets collection of sections.
     */
    sections: SectionLinkCollection;
    constructor(init?: Partial<SectionLinkCollectionResponse>);
}
/**
 * This response should be returned by the service when handling: GET http://api.aspose.com/v4.0/words/Test.doc/sections/{0}/PageSetup.
 */
export declare class SectionPageSetupResponse extends WordsResponse {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets section.
     */
    pageSetup: PageSetup;
    constructor(init?: Partial<SectionPageSetupResponse>);
}
/**
 * This response should be returned by the service when handling: GET http://api.aspose.com/v4.0/words/Test.doc/sections/{0}.
 */
export declare class SectionResponse extends WordsResponse {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets section.
     */
    section: Section;
    constructor(init?: Partial<SectionResponse>);
}
/**
 * This response should be returned by the service when handling:  POST /{name}/split .
 */
export declare class SplitDocumentResponse extends WordsResponse {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets resylt of splitting document.
     */
    splitResult: SplitDocumentResult;
    constructor(init?: Partial<SplitDocumentResponse>);
}
/**
 * Response for the request of the document's statistical data.
 */
export declare class StatDataResponse extends WordsResponse {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets link to the document.
     */
    documentLink: FileLink;
    /**
     * Gets or sets statistical data of the document.
     */
    statData: DocumentStatData;
    constructor(init?: Partial<StatDataResponse>);
}
/**
 * Represents all formatting for a table row.
 */
export declare class TableCellFormat extends LinkElement {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets returns or sets the amount of space (in points) to add below the contents of cell.
     */
    bottomPadding: number;
    /**
     * Gets or sets if true, fits text in the cell, compressing each paragraph to the width of the cell.
     */
    fitText: boolean;
    /**
     * Gets or sets specifies how the cell is merged horizontally with other cells in the row.
     */
    horizontalMerge: TableCellFormat.HorizontalMergeEnum;
    /**
     * Gets or sets returns or sets the amount of space (in points) to add to the left of the contents of cell.
     */
    leftPadding: number;
    /**
     * Gets or sets returns or sets the orientation of text in a table cell.
     */
    orientation: TableCellFormat.OrientationEnum;
    /**
     * Gets or sets returns or sets the preferred width of the cell.
     */
    preferredWidth: PreferredWidth;
    /**
     * Gets or sets returns or sets the amount of space (in points) to add to the right of the contents of cell.
     */
    rightPadding: number;
    /**
     * Gets or sets returns or sets the amount of space (in points) to add above the contents of cell.
     */
    topPadding: number;
    /**
     * Gets or sets returns or sets the vertical alignment of text in the cell.
     */
    verticalAlignment: TableCellFormat.VerticalAlignmentEnum;
    /**
     * Gets or sets specifies how the cell is merged with other cells vertically.
     */
    verticalMerge: TableCellFormat.VerticalMergeEnum;
    /**
     * Gets or sets the width of the cell in points.
     */
    width: number;
    /**
     * Gets or sets if true, wrap text for the cell.
     */
    wrapText: boolean;
    constructor(init?: Partial<TableCellFormat>);
}
/**
 * Enums for TableCellFormat
 */
export declare namespace TableCellFormat {
    enum HorizontalMergeEnum {
        None,
        First,
        Previous
    }
    enum OrientationEnum {
        Horizontal,
        Downward,
        Upward,
        HorizontalRotatedFarEast,
        VerticalFarEast,
        VerticalRotatedFarEast
    }
    enum VerticalAlignmentEnum {
        Top,
        Center,
        Bottom
    }
    enum VerticalMergeEnum {
        None,
        First,
        Previous
    }
}
/**
 * This response should be returned by the service when handling: GET http://api.aspose.com/v4.0/words/Test.doc/tables/{0}/rows/{1}/cells/{2}/cellformat.
 */
export declare class TableCellFormatResponse extends WordsResponse {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets table.
     */
    cellFormat: TableCellFormat;
    constructor(init?: Partial<TableCellFormatResponse>);
}
/**
 * This response should be returned by the service when handling: GET http://api.aspose.com/v4.0/words/Test.doc/tables/{0}.
 */
export declare class TableCellResponse extends WordsResponse {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets table cell.
     */
    cell: TableCell;
    constructor(init?: Partial<TableCellResponse>);
}
/**
 * Collection of links to tables.
 */
export declare class TableLinkCollection extends LinkElement {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets collection of table's links.
     */
    tableLinkList: Array<TableLink>;
    constructor(init?: Partial<TableLinkCollection>);
}
/**
 * This response should be returned by the service when handling: GET http://api.aspose.com/v4.0/words/Test.doc/tables.
 */
export declare class TableLinkCollectionResponse extends WordsResponse {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets collection of tables.
     */
    tables: TableLinkCollection;
    constructor(init?: Partial<TableLinkCollectionResponse>);
}
/**
 * Represents the table properties.
 */
export declare class TableProperties extends LinkElement {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets specifies how an inline table is aligned in the document.
     */
    alignment: TableProperties.AlignmentEnum;
    /**
     * Gets or sets allows Microsoft Word and Aspose.Words to automatically resize cells in a table to fit their contents.
     */
    allowAutoFit: boolean;
    /**
     * Gets or sets whether this is a right-to-left table.
     */
    bidi: boolean;
    /**
     * Gets or sets the amount of space (in points) to add below the contents of cells.
     */
    bottomPadding: number;
    /**
     * Gets or sets the amount of space (in points) between the cells.
     */
    cellSpacing: number;
    /**
     * Gets or sets the value that represents the left indent of the table.
     */
    leftIndent: number;
    /**
     * Gets or sets the amount of space (in points) to add to the left of the contents of cells.
     */
    leftPadding: number;
    /**
     * Gets or sets the table preferred width. Preferred width can be specified as a percentage, number of points or a special \"auto\" value.
     */
    preferredWidth: PreferredWidth;
    /**
     * Gets or sets the amount of space (in points) to add to the right of the contents of cells.
     */
    rightPadding: number;
    /**
     * Gets or sets the locale independent style identifier of the table style applied to this table.
     */
    styleIdentifier: TableProperties.StyleIdentifierEnum;
    /**
     * Gets or sets the name of the table style applied to this table.
     */
    styleName: string;
    /**
     * Gets or sets bit flags that specify how a table style is applied to this table.
     */
    styleOptions: TableProperties.StyleOptionsEnum;
    /**
     * Gets or sets get or sets TextWrapping  for table.
     */
    textWrapping: TableProperties.TextWrappingEnum;
    /**
     * Gets or sets the amount of space (in points) to add above the contents of cells.
     */
    topPadding: number;
    constructor(init?: Partial<TableProperties>);
}
/**
 * Enums for TableProperties
 */
export declare namespace TableProperties {
    enum AlignmentEnum {
        Left,
        Center,
        Right
    }
    enum StyleIdentifierEnum {
        Normal,
        Heading1,
        Heading2,
        Heading3,
        Heading4,
        Heading5,
        Heading6,
        Heading7,
        Heading8,
        Heading9,
        Index1,
        Index2,
        Index3,
        Index4,
        Index5,
        Index6,
        Index7,
        Index8,
        Index9,
        Toc1,
        Toc2,
        Toc3,
        Toc4,
        Toc5,
        Toc6,
        Toc7,
        Toc8,
        Toc9,
        NormalIndent,
        FootnoteText,
        CommentText,
        Header,
        Footer,
        IndexHeading,
        Caption,
        TableOfFigures,
        EnvelopeAddress,
        EnvelopeReturn,
        FootnoteReference,
        CommentReference,
        LineNumber,
        PageNumber,
        EndnoteReference,
        EndnoteText,
        TableOfAuthorities,
        Macro,
        ToaHeading,
        List,
        ListBullet,
        ListNumber,
        List2,
        List3,
        List4,
        List5,
        ListBullet2,
        ListBullet3,
        ListBullet4,
        ListBullet5,
        ListNumber2,
        ListNumber3,
        ListNumber4,
        ListNumber5,
        Title,
        Closing,
        Signature,
        DefaultParagraphFont,
        BodyText,
        BodyTextInd,
        ListContinue,
        ListContinue2,
        ListContinue3,
        ListContinue4,
        ListContinue5,
        MessageHeader,
        Subtitle,
        Salutation,
        Date,
        BodyText1I,
        BodyText1I2,
        NoteHeading,
        BodyText2,
        BodyText3,
        BodyTextInd2,
        BodyTextInd3,
        BlockText,
        Hyperlink,
        FollowedHyperlink,
        Strong,
        Emphasis,
        DocumentMap,
        PlainText,
        EmailSignature,
        HtmlTopOfForm,
        HtmlBottomOfForm,
        NormalWeb,
        HtmlAcronym,
        HtmlAddress,
        HtmlCite,
        HtmlCode,
        HtmlDefinition,
        HtmlKeyboard,
        HtmlPreformatted,
        HtmlSample,
        HtmlTypewriter,
        HtmlVariable,
        TableNormal,
        CommentSubject,
        NoList,
        OutlineList1,
        OutlineList2,
        OutlineList3,
        TableSimple1,
        TableSimple2,
        TableSimple3,
        TableClassic1,
        TableClassic2,
        TableClassic3,
        TableClassic4,
        TableColorful1,
        TableColorful2,
        TableColorful3,
        TableColumns1,
        TableColumns2,
        TableColumns3,
        TableColumns4,
        TableColumns5,
        TableGrid1,
        TableGrid2,
        TableGrid3,
        TableGrid4,
        TableGrid5,
        TableGrid6,
        TableGrid7,
        TableGrid8,
        TableList1,
        TableList2,
        TableList3,
        TableList4,
        TableList5,
        TableList6,
        TableList7,
        TableList8,
        Table3DEffects1,
        Table3DEffects2,
        Table3DEffects3,
        TableContemporary,
        TableElegant,
        TableProfessional,
        TableSubtle1,
        TableSubtle2,
        TableWeb1,
        TableWeb2,
        TableWeb3,
        BalloonText,
        TableGrid,
        TableTheme,
        PlaceholderText,
        NoSpacing,
        LightShading,
        LightList,
        LightGrid,
        MediumShading1,
        MediumShading2,
        MediumList1,
        MediumList2,
        MediumGrid1,
        MediumGrid2,
        MediumGrid3,
        DarkList,
        ColorfulShading,
        ColorfulList,
        ColorfulGrid,
        LightShadingAccent1,
        LightListAccent1,
        LightGridAccent1,
        MediumShading1Accent1,
        MediumShading2Accent1,
        MediumList1Accent1,
        Revision,
        ListParagraph,
        Quote,
        IntenseQuote,
        MediumList2Accent1,
        MediumGrid1Accent1,
        MediumGrid2Accent1,
        MediumGrid3Accent1,
        DarkListAccent1,
        ColorfulShadingAccent1,
        ColorfulListAccent1,
        ColorfulGridAccent1,
        LightShadingAccent2,
        LightListAccent2,
        LightGridAccent2,
        MediumShading1Accent2,
        MediumShading2Accent2,
        MediumList1Accent2,
        MediumList2Accent2,
        MediumGrid1Accent2,
        MediumGrid2Accent2,
        MediumGrid3Accent2,
        DarkListAccent2,
        ColorfulShadingAccent2,
        ColorfulListAccent2,
        ColorfulGridAccent2,
        LightShadingAccent3,
        LightListAccent3,
        LightGridAccent3,
        MediumShading1Accent3,
        MediumShading2Accent3,
        MediumList1Accent3,
        MediumList2Accent3,
        MediumGrid1Accent3,
        MediumGrid2Accent3,
        MediumGrid3Accent3,
        DarkListAccent3,
        ColorfulShadingAccent3,
        ColorfulListAccent3,
        ColorfulGridAccent3,
        LightShadingAccent4,
        LightListAccent4,
        LightGridAccent4,
        MediumShading1Accent4,
        MediumShading2Accent4,
        MediumList1Accent4,
        MediumList2Accent4,
        MediumGrid1Accent4,
        MediumGrid2Accent4,
        MediumGrid3Accent4,
        DarkListAccent4,
        ColorfulShadingAccent4,
        ColorfulListAccent4,
        ColorfulGridAccent4,
        LightShadingAccent5,
        LightListAccent5,
        LightGridAccent5,
        MediumShading1Accent5,
        MediumShading2Accent5,
        MediumList1Accent5,
        MediumList2Accent5,
        MediumGrid1Accent5,
        MediumGrid2Accent5,
        MediumGrid3Accent5,
        DarkListAccent5,
        ColorfulShadingAccent5,
        ColorfulListAccent5,
        ColorfulGridAccent5,
        LightShadingAccent6,
        LightListAccent6,
        LightGridAccent6,
        MediumShading1Accent6,
        MediumShading2Accent6,
        MediumList1Accent6,
        MediumList2Accent6,
        MediumGrid1Accent6,
        MediumGrid2Accent6,
        MediumGrid3Accent6,
        DarkListAccent6,
        ColorfulShadingAccent6,
        ColorfulListAccent6,
        ColorfulGridAccent6,
        SubtleEmphasis,
        IntenseEmphasis,
        SubtleReference,
        IntenseReference,
        BookTitle,
        Bibliography,
        TocHeading,
        PlainTable1,
        PlainTable2,
        PlainTable3,
        PlainTable4,
        PlainTable5,
        TableGridLight,
        GridTable1Light,
        GridTable2,
        GridTable3,
        GridTable4,
        GridTable5Dark,
        GridTable6Colorful,
        GridTable7Colorful,
        GridTable1LightAccent1,
        GridTable2Accent1,
        GridTable3Accent1,
        GridTable4Accent1,
        GridTable5DarkAccent1,
        GridTable6ColorfulAccent1,
        GridTable7ColorfulAccent1,
        GridTable1LightAccent2,
        GridTable2Accent2,
        GridTable3Accent2,
        GridTable4Accent2,
        GridTable5DarkAccent2,
        GridTable6ColorfulAccent2,
        GridTable7ColorfulAccent2,
        GridTable1LightAccent3,
        GridTable2Accent3,
        GridTable3Accent3,
        GridTable4Accent3,
        GridTable5DarkAccent3,
        GridTable6ColorfulAccent3,
        GridTable7ColorfulAccent3,
        GridTable1LightAccent4,
        GridTable2Accent4,
        GridTable3Accent4,
        GridTable4Accent4,
        GridTable5DarkAccent4,
        GridTable6ColorfulAccent4,
        GridTable7ColorfulAccent4,
        GridTable1LightAccent5,
        GridTable2Accent5,
        GridTable3Accent5,
        GridTable4Accent5,
        GridTable5DarkAccent5,
        GridTable6ColorfulAccent5,
        GridTable7ColorfulAccent5,
        GridTable1LightAccent6,
        GridTable2Accent6,
        GridTable3Accent6,
        GridTable4Accent6,
        GridTable5DarkAccent6,
        GridTable6ColorfulAccent6,
        GridTable7ColorfulAccent6,
        ListTable1Light,
        ListTable2,
        ListTable3,
        ListTable4,
        ListTable5Dark,
        ListTable6Colorful,
        ListTable7Colorful,
        ListTable1LightAccent1,
        ListTable2Accent1,
        ListTable3Accent1,
        ListTable4Accent1,
        ListTable5DarkAccent1,
        ListTable6ColorfulAccent1,
        ListTable7ColorfulAccent1,
        ListTable1LightAccent2,
        ListTable2Accent2,
        ListTable3Accent2,
        ListTable4Accent2,
        ListTable5DarkAccent2,
        ListTable6ColorfulAccent2,
        ListTable7ColorfulAccent2,
        ListTable1LightAccent3,
        ListTable2Accent3,
        ListTable3Accent3,
        ListTable4Accent3,
        ListTable5DarkAccent3,
        ListTable6ColorfulAccent3,
        ListTable7ColorfulAccent3,
        ListTable1LightAccent4,
        ListTable2Accent4,
        ListTable3Accent4,
        ListTable4Accent4,
        ListTable5DarkAccent4,
        ListTable6ColorfulAccent4,
        ListTable7ColorfulAccent4,
        ListTable1LightAccent5,
        ListTable2Accent5,
        ListTable3Accent5,
        ListTable4Accent5,
        ListTable5DarkAccent5,
        ListTable6ColorfulAccent5,
        ListTable7ColorfulAccent5,
        ListTable1LightAccent6,
        ListTable2Accent6,
        ListTable3Accent6,
        ListTable4Accent6,
        ListTable5DarkAccent6,
        ListTable6ColorfulAccent6,
        ListTable7ColorfulAccent6,
        User,
        Nil
    }
    enum StyleOptionsEnum {
        None,
        FirstRow,
        LastRow,
        FirstColumn,
        LastColumn,
        RowBands,
        Default,
        ColumnBands,
        Default2003
    }
    enum TextWrappingEnum {
        Default,
        None,
        Around
    }
}
/**
 * This response should be returned by the service when handling: GET http://api.aspose.com/v4.0/words/Test.doc/tables/{0}/properties.
 */
export declare class TablePropertiesResponse extends WordsResponse {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets table.
     */
    properties: TableProperties;
    constructor(init?: Partial<TablePropertiesResponse>);
}
/**
 * This response should be returned by the service when handling: GET http://api.aspose.com/v4.0/words/Test.doc/tables/{0}.
 */
export declare class TableResponse extends WordsResponse {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets table.
     */
    table: Table;
    constructor(init?: Partial<TableResponse>);
}
/**
 * Represents all formatting for a table row.
 */
export declare class TableRowFormat extends LinkElement {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets true if the text in a table row is allowed to split across a page break.
     */
    allowBreakAcrossPages: boolean;
    /**
     * Gets or sets true if the row is repeated as a table heading on every page when the table spans more than one page.
     */
    headingFormat: boolean;
    /**
     * Gets or sets the height of the table row in points.
     */
    height: number;
    /**
     * Gets or sets the rule for determining the height of the table row.
     */
    heightRule: TableRowFormat.HeightRuleEnum;
    constructor(init?: Partial<TableRowFormat>);
}
/**
 * Enums for TableRowFormat
 */
export declare namespace TableRowFormat {
    enum HeightRuleEnum {
        AtLeast,
        Exactly,
        Auto
    }
}
/**
 * This response should be returned by the service when handling: GET http://api.aspose.com/v4.0/words/Test.doc/tables/{0}/rows/{1}/rowformat.
 */
export declare class TableRowFormatResponse extends WordsResponse {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets table.
     */
    rowFormat: TableRowFormat;
    constructor(init?: Partial<TableRowFormatResponse>);
}
/**
 * This response should be returned by the service when handling: GET http://api.aspose.com/v4.0/words/Test.doc/tables/{0}.
 */
export declare class TableRowResponse extends WordsResponse {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets table row.
     */
    row: TableRow;
    constructor(init?: Partial<TableRowResponse>);
}
/**
 * Container class for text save options.
 */
export declare class TextSaveOptionsData extends SaveOptionsData {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets specifies whether to add bi-directional marks before each BiDi run when exporting in plain text format. The default value is true.
     */
    addBidiMarks: boolean;
    /**
     * Gets or sets specifies the encoding to use when exporting in plain text format.
     */
    encoding: string;
    /**
     * Gets or sets specifies whether to output headers and footers when exporting in plain text format. default value is TxtExportHeadersFootersMode.PrimaryOnly.
     */
    exportHeadersFootersMode: TextSaveOptionsData.ExportHeadersFootersModeEnum;
    /**
     * Gets or sets allows to specify whether the page breaks should be preserved during export. The default value is false.
     */
    forcePageBreaks: boolean;
    /**
     * Gets or sets specifies the string to use as a paragraph break when exporting in plain text format.
     */
    paragraphBreak: string;
    /**
     * Gets or sets specifies whether the program should attempt to preserve layout of tables when saving in the plain text format.
     */
    preserveTableLayout: boolean;
    /**
     * Gets or sets specifies whether the program should simplify list labels in case of complex label formatting not being adequately represented by plain text.
     */
    simplifyListLabels: boolean;
    constructor(init?: Partial<TextSaveOptionsData>);
}
/**
 * Enums for TextSaveOptionsData
 */
export declare namespace TextSaveOptionsData {
    enum ExportHeadersFootersModeEnum {
        None,
        PrimaryOnly,
        AllAtEnd
    }
}
/**
 * container class for wml save options.
 */
export declare class WordMLSaveOptionsData extends SaveOptionsData {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets specifies whether or not use pretty formats output.
     */
    prettyFormat: boolean;
    constructor(init?: Partial<WordMLSaveOptionsData>);
}
/**
 * Response for Api error.
 */
export declare class WordsApiErrorResponse extends WordsResponse {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets error.
     */
    error: ApiError;
    constructor(init?: Partial<WordsApiErrorResponse>);
}
/**
 * Provides information for the words api resource link.
 */
export declare class WordsApiLink extends Link {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    constructor(init?: Partial<WordsApiLink>);
}
/**
 * container class for xaml flow save options.
 */
export declare class XamlFlowSaveOptionsData extends SaveOptionsData {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets specifies the physical folder where images are saved when exporting.
     */
    imagesFolder: string;
    /**
     * Gets or sets specifies the name of the folder used to construct image URIs.
     */
    imagesFolderAlias: string;
    constructor(init?: Partial<XamlFlowSaveOptionsData>);
}
/**
 * Comment.
 */
export declare class Comment extends CommentLink {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets returns or sets the author name for a comment.
     */
    author: string;
    /**
     * Gets or sets content of comment.
     */
    content: StoryChildNodes;
    /**
     * Gets or sets the date and time that the comment was made.
     */
    dateTime: Date;
    /**
     * Gets or sets returns or sets the initials of the user associated with a specific comment.
     */
    initial: string;
    /**
     * Gets or sets link to comment range end node.
     */
    rangeEnd: DocumentPosition;
    /**
     * Gets or sets link to comment range start node.
     */
    rangeStart: DocumentPosition;
    /**
     * Gets or sets this is a convenience property that allows to easily get or set text of the comment.
     */
    text: string;
    constructor(init?: Partial<Comment>);
}
/**
 * Represents link for Drawing Object DTO.
 */
export declare class DrawingObjectLink extends NodeLink {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    constructor(init?: Partial<DrawingObjectLink>);
}
/**
 * Container class for epub save options.
 */
export declare class EpubSaveOptionsData extends HtmlSaveOptionsData {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets specifies the maximum level of headings populated to the navigation map when exporting.
     */
    epubNavigationMapLevel: number;
    constructor(init?: Partial<EpubSaveOptionsData>);
}
/**
 * Enums for EpubSaveOptionsData
 */
export declare namespace EpubSaveOptionsData {
}
/**
 * Field link.
 */
export declare class FieldLink extends NodeLink {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets field code.
     */
    fieldCode: string;
    constructor(init?: Partial<FieldLink>);
}
/**
 * Footnote link.
 */
export declare class FootnoteLink extends NodeLink {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    constructor(init?: Partial<FootnoteLink>);
}
/**
 * FromField.
 */
export declare class FormField extends NodeLink {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets true if references to the specified form field are automatically updated whenever the field is exited.
     */
    calculateOnExit: boolean;
    /**
     * Gets or sets true if a form field is enabled.
     */
    enabled: boolean;
    /**
     * Gets or sets returns or sets an entry macro name for the form field.
     */
    entryMacro: string;
    /**
     * Gets or sets returns or sets an exit macro name for the form field.
     */
    exitMacro: string;
    /**
     * Gets or sets returns or sets the text that's displayed in a message box when the form field has the focus and the user presses F1.
     */
    helpText: string;
    /**
     * Gets or sets the form field name.
     */
    name: string;
    /**
     * Gets or sets specifies the source of the text that's displayed in a message box when a form field has the focus and the user presses F1.
     */
    ownHelp: boolean;
    /**
     * Gets or sets specifies the source of the text that's displayed in the status bar when a form field has the focus.
     */
    ownStatus: boolean;
    /**
     * Gets or sets returns or sets the text that's displayed in the status bar when a form field has the focus.
     */
    statusText: string;
    constructor(init?: Partial<FormField>);
}
/**
 * Section element.
 */
export declare class HeaderFooter extends HeaderFooterLink {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets child nodes.
     */
    childNodes: Array<NodeLink>;
    /**
     * Gets or sets link to DrawingObjects resource.
     */
    drawingObjects: LinkElement;
    /**
     * Gets or sets link to Paragraphs resource.
     */
    paragraphs: LinkElement;
    constructor(init?: Partial<HeaderFooter>);
}
/**
 * Enums for HeaderFooter
 */
export declare namespace HeaderFooter {
}
/**
 * container class for fixed html save options.
 */
export declare class HtmlFixedSaveOptionsData extends FixedPageSaveOptionsData {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets specifies prefix which is added to all class names in style.css file. Default value is \"aw\".
     */
    cssClassNamesPrefix: string;
    /**
     * Gets or sets encoding.
     */
    encoding: string;
    /**
     * Gets or sets specifies whether the CSS (Cascading Style Sheet) should be embedded into Html document.
     */
    exportEmbeddedCss: boolean;
    /**
     * Gets or sets specifies whether fonts should be embedded into Html document in Base64 format.
     */
    exportEmbeddedFonts: boolean;
    /**
     * Gets or sets specifies whether images should be embedded into Html document in Base64 format.
     */
    exportEmbeddedImages: boolean;
    /**
     * Gets or sets indication of whether form fields are exported as interactive items (as 'input' tag) rather than converted to text or graphics.
     */
    exportFormFields: boolean;
    /**
     * Gets or sets specifies export format of fonts.
     */
    fontFormat: string;
    /**
     * Gets or sets specifies the horizontal alignment of pages in an HTML document. Default value is HtmlFixedHorizontalPageAlignment.Center.
     */
    pageHorizontalAlignment: string;
    /**
     * Gets or sets specifies the margins around pages in an HTML document. The margins value is measured in points and should be equal to or greater than 0. Default value is 10 points.
     */
    pageMargins: number;
    /**
     * Gets or sets specifies the physical folder where resources are saved when exporting a document.
     */
    resourcesFolder: string;
    /**
     * Gets or sets specifies the name of the folder used to construct resource URIs.
     */
    resourcesFolderAlias: string;
    /**
     * Gets or sets flag indicates whether \"@font-face\" CSS rules should be placed into a separate file \"fontFaces.css\" when a document is being saved with external stylesheet (that is, when Aspose.Words.Saving.HtmlFixedSaveOptions.ExportEmbeddedCss is false). Default value is false, all CSS rules are written into single file \"styles.css\".
     */
    saveFontFaceCssSeparately: boolean;
    /**
     * Gets or sets specifies whether border around pages should be shown.
     */
    showPageBorder: boolean;
    constructor(init?: Partial<HtmlFixedSaveOptionsData>);
}
/**
 * Container abstract class for image save options.
 */
export declare class ImageSaveOptionsData extends FixedPageSaveOptionsData {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets allows to specify additional System.Drawing.Graphics quality options.
     */
    graphicsQualityOptions: GraphicsQualityOptionsData;
    /**
     * Gets or sets the horizontal resolution for the generated images, in dots per inch.  This property has effect only when saving to raster image formats. The default value is 96.
     */
    horizontalResolution: number;
    /**
     * Gets or sets brightness of image.
     */
    imageBrightness: number;
    /**
     * Gets or sets color mode of image.
     */
    imageColorMode: string;
    /**
     * Gets or sets contrast of image.
     */
    imageContrast: number;
    /**
     * Gets or sets background (paper) color of image.
     */
    paperColor: string;
    /**
     * Gets or sets pixel format of image.
     */
    pixelFormat: string;
    /**
     * Gets or sets both horizontal and vertical resolution for the generated images, in dots per inch.  This property has effect only when saving to raster image formats. The default value is 96.
     */
    resolution: number;
    /**
     * Gets or sets zoom factor of image.
     */
    scale: number;
    /**
     * Gets or sets determine whether or not to use anti-aliasing for rendering.
     */
    useAntiAliasing: boolean;
    /**
     * Gets or sets a value determining whether to use GDI+ or Aspose.Words metafile renderer when saving to EMF.
     */
    useGdiEmfRenderer: boolean;
    /**
     * Gets or sets determine whether or not to use high quality (i.e. slow) rendering algorithms.
     */
    useHighQualityRendering: boolean;
    /**
     * Gets or sets the vertical resolution for the generated images, in dots per inch.  This property has effect only when saving to raster image formats. The default value is 96.
     */
    verticalResolution: number;
    constructor(init?: Partial<ImageSaveOptionsData>);
}
/**
 * Container class for mhtml save options.
 */
export declare class MhtmlSaveOptionsData extends HtmlSaveOptionsData {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets specifies whether to use CID (Content-ID) URLs to reference resources (images, fonts, CSS) included in MHTML documents. Default value is false.
     */
    exportCidUrlsForMhtmlResources: boolean;
    constructor(init?: Partial<MhtmlSaveOptionsData>);
}
/**
 * Enums for MhtmlSaveOptionsData
 */
export declare namespace MhtmlSaveOptionsData {
}
/**
 * OfficeMath object link element.
 */
export declare class OfficeMathLink extends NodeLink {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    constructor(init?: Partial<OfficeMathLink>);
}
/**
 * Paragraph element.
 */
export declare class Paragraph extends NodeLink {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets child nodes.
     */
    childNodes: Array<NodeLink>;
    constructor(init?: Partial<Paragraph>);
}
/**
 * Paragraph link element.
 */
export declare class ParagraphLink extends NodeLink {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets paragraph's text.
     */
    text: string;
    constructor(init?: Partial<ParagraphLink>);
}
/**
 * Container class for pcl save options.
 */
export declare class PclSaveOptionsData extends FixedPageSaveOptionsData {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets name of the font that will be used if no expected font is found in printer and built-in fonts collections.
     */
    falllbackFontName: string;
    /**
     * Gets or sets a value determining whether or not complex transformed elements should be rasterized before saving to PCL document.  Default is true.
     */
    rasterizeTransformedElements: boolean;
    constructor(init?: Partial<PclSaveOptionsData>);
}
/**
 * container class for pdf save options.
 */
export declare class PdfSaveOptionsData extends FixedPageSaveOptionsData {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets specifies the PDF standards compliance level for output documents.
     */
    compliance: string;
    /**
     * Gets or sets specifies whether to convert footnote/endnote references in main text story into active hyperlinks. When clicked the hyperlink will lead to the corresponding footnote/endnote. Default is false.
     */
    createNoteHyperlinks: boolean;
    /**
     * Gets or sets a value determining the way  are exported to PDF file. Default value is .
     */
    customPropertiesExport: string;
    /**
     * Gets or sets specifies the details for signing the output PDF document.
     */
    digitalSignatureDetails: PdfDigitalSignatureDetailsData;
    /**
     * Gets or sets a flag specifying whether the window�s title bar should display the document title taken from the Title entry of the document information dictionary.
     */
    displayDocTitle: boolean;
    /**
     * Gets or sets allows to specify downsample options.
     */
    downsampleOptions: DownsampleOptionsData;
    /**
     * Gets or sets controls how fonts are embedded into the resulting PDF documents.
     */
    embedFullFonts: boolean;
    /**
     * Gets or sets specifies the details for encrypting the output PDF document.
     */
    encryptionDetails: PdfEncryptionDetailsData;
    /**
     * Gets or sets a flag specifying whether URI should be escaped before writing.
     */
    escapeUri: boolean;
    /**
     * Gets or sets determines whether or not to export document structure.
     */
    exportDocumentStructure: boolean;
    /**
     * Gets or sets specifies the font embedding mode.
     */
    fontEmbeddingMode: string;
    /**
     * Gets or sets determines how bookmarks in headers/footers are exported. The default value is Aspose.Words.Saving.HeaderFooterBookmarksExportMode.All.
     */
    headerFooterBookmarksExportMode: PdfSaveOptionsData.HeaderFooterBookmarksExportModeEnum;
    /**
     * Gets or sets specifies how the color space will be selected for the images in PDF document.
     */
    imageColorSpaceExportMode: string;
    /**
     * Gets or sets specifies compression type to be used for all images in the document.
     */
    imageCompression: string;
    /**
     * Gets or sets determines whether hyperlinks in the output Pdf document are forced to be opened in a new window (or tab) of a browser.
     */
    openHyperlinksInNewWindow: boolean;
    /**
     * Gets or sets allows to specify outline options.
     */
    outlineOptions: OutlineOptionsData;
    /**
     * Gets or sets specifies how the PDF document should be displayed when opened in the PDF reader.
     */
    pageMode: string;
    /**
     * Gets or sets a value determining whether or not to preblend transparent images with black background color.
     */
    preblendImages: boolean;
    /**
     * Gets or sets specifies whether to preserve Microsoft Word form fields as form fields in PDF or convert them to text.
     */
    preserveFormFields: boolean;
    /**
     * Gets or sets specifies compression type to be used for all textual content in the document.
     */
    textCompression: string;
    /**
     * Gets or sets determines whether the document should be saved using a booklet printing layout.
     */
    useBookFoldPrintingSettings: boolean;
    /**
     * Gets or sets determines whether or not to substitute TrueType fonts Arial, Times New Roman, Courier New and Symbol with core PDF Type 1 fonts.
     */
    useCoreFonts: boolean;
    /**
     * Gets or sets determines what type of zoom should be applied when a document is opened with a PDF viewer.
     */
    zoomBehavior: string;
    /**
     * Gets or sets determines zoom factor (in percentages) for a document.
     */
    zoomFactor: number;
    constructor(init?: Partial<PdfSaveOptionsData>);
}
/**
 * Enums for PdfSaveOptionsData
 */
export declare namespace PdfSaveOptionsData {
    enum HeaderFooterBookmarksExportModeEnum {
        None,
        First,
        All
    }
}
/**
 * container class for ps save options.
 */
export declare class PsSaveOptionsData extends FixedPageSaveOptionsData {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets determines whether the document should be saved using a booklet printing layout.
     */
    useBookFoldPrintingSettings: boolean;
    constructor(init?: Partial<PsSaveOptionsData>);
}
/**
 * Run link element.
 */
export declare class RunLink extends NodeLink {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets run's text.
     */
    text: string;
    constructor(init?: Partial<RunLink>);
}
/**
 * Section link element.
 */
export declare class SectionLink extends NodeLink {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    constructor(init?: Partial<SectionLink>);
}
/**
 * container class for svg save options.
 */
export declare class SvgSaveOptionsData extends FixedPageSaveOptionsData {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets specified whether images should be embedded into SVG document as base64.
     */
    exportEmbeddedImages: boolean;
    /**
     * Gets or sets specifies if the output SVG should fill the available viewport area (browser window or container). When set to true width and height of output SVG are set to 100%.
     */
    fitToViewPort: boolean;
    /**
     * Gets or sets specifies the physical folder where resources (images) are saved when exporting.
     */
    resourcesFolder: string;
    /**
     * Gets or sets specifies the name of the folder used to construct image URIs.
     */
    resourcesFolderAlias: string;
    /**
     * Gets or sets show/hide page stepper.
     */
    showPageBorder: boolean;
    /**
     * Gets or sets determines how text should be rendered.
     */
    textOutputMode: string;
    constructor(init?: Partial<SvgSaveOptionsData>);
}
/**
 * Table element.
 */
export declare class Table extends NodeLink {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets table properties.
     */
    tableProperties: TableProperties;
    /**
     * Gets or sets collection of table's rows.
     */
    tableRowList: Array<TableRow>;
    constructor(init?: Partial<Table>);
}
/**
 * Table cell element.
 */
export declare class TableCell extends NodeLink {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets child nodes.
     */
    childNodes: Array<NodeLink>;
    constructor(init?: Partial<TableCell>);
}
/**
 * Table link element.
 */
export declare class TableLink extends NodeLink {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    constructor(init?: Partial<TableLink>);
}
/**
 * Table row element.
 */
export declare class TableRow extends NodeLink {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets provides access to the formatting properties of the row.
     */
    rowFormat: TableRowFormat;
    /**
     * Gets or sets collection of table's rows.
     */
    tableCellList: Array<TableCell>;
    constructor(init?: Partial<TableRow>);
}
/**
 * container class for xaml fixed save options.
 */
export declare class XamlFixedSaveOptionsData extends FixedPageSaveOptionsData {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets specifies the physical folder where resources (images and fonts) are saved when exporting a document to fixed page Xaml format. Default is null.
     */
    resourcesFolder: string;
    /**
     * Gets or sets specifies the name of the folder used to construct image URIs written into an fixed page Xaml document. Default is null.
     */
    resourcesFolderAlias: string;
    constructor(init?: Partial<XamlFixedSaveOptionsData>);
}
/**
 * Container class for xps save options.
 */
export declare class XpsSaveOptionsData extends FixedPageSaveOptionsData {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets specifies the level in the XPS document outline at which to display Word bookmarks.
     */
    bookmarksOutlineLevel: number;
    /**
     * Gets or sets specifies how many levels of headings (paragraphs formatted with the Heading styles) to include in the XPS document outline.
     */
    headingsOutlineLevels: number;
    /**
     * Gets or sets allows to specify outline options.
     */
    outlineOptions: OutlineOptionsData;
    /**
     * Gets or sets determines whether the document should be saved using a booklet printing layout.
     */
    useBookFoldPrintingSettings: boolean;
    constructor(init?: Partial<XpsSaveOptionsData>);
}
/**
 * Container class for bmp save options.
 */
export declare class BmpSaveOptionsData extends ImageSaveOptionsData {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    constructor(init?: Partial<BmpSaveOptionsData>);
}
/**
 * Represents Drawing Object DTO.
 */
export declare class DrawingObject extends DrawingObjectLink {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets height of the drawing object in points.
     */
    height: number;
    /**
     * Gets or sets link to image data. Can be null if shape does not have an image.
     */
    imageDataLink: WordsApiLink;
    /**
     * Gets or sets distance in points from the origin to the left side of the image.
     */
    left: number;
    /**
     * Gets or sets link to ole object. Can be null if shape does not have ole data.
     */
    oleDataLink: WordsApiLink;
    /**
     * Gets or sets specifies where the distance to the image is measured from.
     */
    relativeHorizontalPosition: DrawingObject.RelativeHorizontalPositionEnum;
    /**
     * Gets or sets specifies where the distance to the image measured from.
     */
    relativeVerticalPosition: DrawingObject.RelativeVerticalPositionEnum;
    /**
     * Gets or sets a list of links that originate from this .
     */
    renderLinks: Array<WordsApiLink>;
    /**
     * Gets or sets distance in points from the origin to the top side of the image.
     */
    top: number;
    /**
     * Gets or sets width of the drawing objects in points.
     */
    width: number;
    /**
     * Gets or sets specifies how to wrap text around the image.
     */
    wrapType: DrawingObject.WrapTypeEnum;
    constructor(init?: Partial<DrawingObject>);
}
/**
 * Enums for DrawingObject
 */
export declare namespace DrawingObject {
    enum RelativeHorizontalPositionEnum {
        Margin,
        Page,
        Column,
        Default,
        Character,
        LeftMargin,
        RightMargin,
        InsideMargin,
        OutsideMargin
    }
    enum RelativeVerticalPositionEnum {
        Margin,
        TableDefault,
        Page,
        Paragraph,
        TextFrameDefault,
        Line,
        TopMargin,
        BottomMargin,
        InsideMargin,
        OutsideMargin
    }
    enum WrapTypeEnum {
        Inline,
        TopBottom,
        Square,
        None,
        Tight,
        Through
    }
}
/**
 * Container class for emf save options.
 */
export declare class EmfSaveOptionsData extends ImageSaveOptionsData {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    constructor(init?: Partial<EmfSaveOptionsData>);
}
/**
 * Field.
 */
export declare class Field extends FieldLink {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets LCID of the field.
     */
    localeId: string;
    /**
     * Gets or sets field result.
     */
    result: string;
    constructor(init?: Partial<Field>);
}
/**
 * Footnote.
 */
export declare class Footnote extends FootnoteLink {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets content of footnote.
     */
    content: StoryChildNodes;
    /**
     * Gets or sets returns a value that specifies whether this is a footnote or endnote.
     */
    footnoteType: Footnote.FootnoteTypeEnum;
    /**
     * Gets or sets link to comment range start node.
     */
    position: DocumentPosition;
    /**
     * Gets or sets /sets custom reference mark to be used for this footnote. Default value is , meaning auto-numbered footnotes are used.
     */
    referenceMark: string;
    /**
     * Gets or sets this is a convenience property that allows to easily get or set text of the footnote.
     */
    text: string;
    constructor(init?: Partial<Footnote>);
}
/**
 * Enums for Footnote
 */
export declare namespace Footnote {
    enum FootnoteTypeEnum {
        Footnote,
        Endnote
    }
}
/**
 * FormField checkbox element.
 */
export declare class FormFieldCheckbox extends FormField {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets the size of the checkbox in points. Has effect only when  is true.
     */
    checkBoxSize: number;
    /**
     * Gets or sets the checked status of the check box form field.
     */
    checked: boolean;
    /**
     * Gets or sets the boolean value that indicates whether the size of the textbox is automatic or specified explicitly.
     */
    isCheckBoxExactSize: boolean;
    constructor(init?: Partial<FormFieldCheckbox>);
}
/**
 * FormField dropdownlist element.
 */
export declare class FormFieldDropDown extends FormField {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets provides access to the items of a dropdown form field.
     */
    dropDownItems: Array<string>;
    /**
     * Gets or sets the index specifying the currently selected item in a dropdown form field.
     */
    dropDownSelectedIndex: number;
    constructor(init?: Partial<FormFieldDropDown>);
}
/**
 * FormField text input element.
 */
export declare class FormFieldTextInput extends FormField {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets maximum length for the text field. Zero when the length is not limited.
     */
    maxLength: number;
    /**
     * Gets or sets the default string or a calculation expression of a text form field.
     */
    textInputDefault: string;
    /**
     * Gets or sets returns or sets the text formatting for a text form field.
     */
    textInputFormat: string;
    /**
     * Gets or sets the type of a text form field.
     */
    textInputType: FormFieldTextInput.TextInputTypeEnum;
    constructor(init?: Partial<FormFieldTextInput>);
}
/**
 * Enums for FormFieldTextInput
 */
export declare namespace FormFieldTextInput {
    enum TextInputTypeEnum {
        Regular,
        Number,
        Date,
        CurrentDate,
        CurrentTime,
        Calculated
    }
}
/**
 * Container class for gif save options.
 */
export declare class GifSaveOptionsData extends ImageSaveOptionsData {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    constructor(init?: Partial<GifSaveOptionsData>);
}
/**
 * container class for jpeg save options.
 */
export declare class JpegSaveOptionsData extends ImageSaveOptionsData {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    constructor(init?: Partial<JpegSaveOptionsData>);
}
/**
 * OfficeMath object.
 */
export declare class OfficeMathObject extends OfficeMathLink {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets content of footnote.
     */
    content: StoryChildNodes;
    /**
     * Gets or sets /sets Office Math display format type which represents whether an equation is displayed inline with the text or displayed on its own line.
     */
    displayType: OfficeMathObject.DisplayTypeEnum;
    /**
     * Gets or sets /sets Office Math justification.
     */
    justification: OfficeMathObject.JustificationEnum;
    /**
     * Gets or sets type Aspose.Words.Math.OfficeMath.MathObjectType of this Office Math object.
     */
    mathObjectType: OfficeMathObject.MathObjectTypeEnum;
    constructor(init?: Partial<OfficeMathObject>);
}
/**
 * Enums for OfficeMathObject
 */
export declare namespace OfficeMathObject {
    enum DisplayTypeEnum {
        Display,
        Inline
    }
    enum JustificationEnum {
        CenterGroup,
        Default,
        Center,
        Left,
        Right,
        Inline
    }
    enum MathObjectTypeEnum {
        OMath,
        OMathPara,
        Accent,
        Bar,
        BorderBox,
        Box,
        Delimiter,
        Degree,
        Argument,
        Array,
        Fraction,
        Denominator,
        Numerator,
        Function,
        FunctionName,
        GroupCharacter,
        Limit,
        LowerLimit,
        UpperLimit,
        Matrix,
        MatrixRow,
        NAry,
        Phantom,
        Radical,
        SubscriptPart,
        SuperscriptPart,
        PreSubSuperscript,
        Subscript,
        SubSuperscript,
        Supercript
    }
}
/**
 * container class for png save options.
 */
export declare class PngSaveOptionsData extends ImageSaveOptionsData {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    constructor(init?: Partial<PngSaveOptionsData>);
}
/**
 * Run element.
 */
export declare class Run extends RunLink {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    constructor(init?: Partial<Run>);
}
/**
 * Container class for tiff save options.
 */
export declare class TiffSaveOptionsData extends ImageSaveOptionsData {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<AttributeInfo>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): AttributeInfo[];
    /**
     * Gets or sets the threshold that determines the value of the binarization error in the Floyd-Steinberg method. when ImageBinarizationMethod is ImageBinarizationMethod.FloydSteinbergDithering. Default value is 128.
     */
    thresholdForFloydSteinbergDithering: number;
    /**
     * Gets or sets specifies method used while converting images to 1 bpp format.
     */
    tiffBinarizationMethod: string;
    /**
     * Gets or sets type of compression.
     */
    tiffCompression: string;
    constructor(init?: Partial<TiffSaveOptionsData>);
}
declare const enumsMap: {
    "Document.SourceFormatEnum": typeof Document.SourceFormatEnum;
    "GraphicsQualityOptionsData.CompositingModeEnum": typeof GraphicsQualityOptionsData.CompositingModeEnum;
    "GraphicsQualityOptionsData.CompositingQualityEnum": typeof GraphicsQualityOptionsData.CompositingQualityEnum;
    "GraphicsQualityOptionsData.InterpolationModeEnum": typeof GraphicsQualityOptionsData.InterpolationModeEnum;
    "GraphicsQualityOptionsData.SmoothingModeEnum": typeof GraphicsQualityOptionsData.SmoothingModeEnum;
    "GraphicsQualityOptionsData.TextRenderingHintEnum": typeof GraphicsQualityOptionsData.TextRenderingHintEnum;
    "PreferredWidth.TypeEnum": typeof PreferredWidth.TypeEnum;
    "ReplaceRange.TextTypeEnum": typeof ReplaceRange.TextTypeEnum;
    "StringFormatData.AlignmentEnum": typeof StringFormatData.AlignmentEnum;
    "StringFormatData.FormatFlagsEnum": typeof StringFormatData.FormatFlagsEnum;
    "StringFormatData.HotkeyPrefixEnum": typeof StringFormatData.HotkeyPrefixEnum;
    "StringFormatData.LineAlignmentEnum": typeof StringFormatData.LineAlignmentEnum;
    "StringFormatData.TrimmingEnum": typeof StringFormatData.TrimmingEnum;
    "Border.BorderTypeEnum": typeof Border.BorderTypeEnum;
    "Border.LineStyleEnum": typeof Border.LineStyleEnum;
    "Font.StyleIdentifierEnum": typeof Font.StyleIdentifierEnum;
    "Font.TextEffectEnum": typeof Font.TextEffectEnum;
    "Font.UnderlineEnum": typeof Font.UnderlineEnum;
    "HeaderFooterLink.TypeEnum": typeof HeaderFooterLink.TypeEnum;
    "HtmlSaveOptionsData.HtmlVersionEnum": typeof HtmlSaveOptionsData.HtmlVersionEnum;
    "HtmlSaveOptionsData.MetafileFormatEnum": typeof HtmlSaveOptionsData.MetafileFormatEnum;
    "HtmlSaveOptionsData.OfficeMathOutputModeEnum": typeof HtmlSaveOptionsData.OfficeMathOutputModeEnum;
    "OdtSaveOptionsData.MeasureUnitEnum": typeof OdtSaveOptionsData.MeasureUnitEnum;
    "PageSetup.BorderAppliesToEnum": typeof PageSetup.BorderAppliesToEnum;
    "PageSetup.BorderDistanceFromEnum": typeof PageSetup.BorderDistanceFromEnum;
    "PageSetup.LineNumberRestartModeEnum": typeof PageSetup.LineNumberRestartModeEnum;
    "PageSetup.OrientationEnum": typeof PageSetup.OrientationEnum;
    "PageSetup.PageNumberStyleEnum": typeof PageSetup.PageNumberStyleEnum;
    "PageSetup.PaperSizeEnum": typeof PageSetup.PaperSizeEnum;
    "PageSetup.SectionStartEnum": typeof PageSetup.SectionStartEnum;
    "PageSetup.VerticalAlignmentEnum": typeof PageSetup.VerticalAlignmentEnum;
    "ParagraphFormat.AlignmentEnum": typeof ParagraphFormat.AlignmentEnum;
    "ParagraphFormat.DropCapPositionEnum": typeof ParagraphFormat.DropCapPositionEnum;
    "ParagraphFormat.LineSpacingRuleEnum": typeof ParagraphFormat.LineSpacingRuleEnum;
    "ParagraphFormat.OutlineLevelEnum": typeof ParagraphFormat.OutlineLevelEnum;
    "ParagraphFormat.StyleIdentifierEnum": typeof ParagraphFormat.StyleIdentifierEnum;
    "TableCellFormat.HorizontalMergeEnum": typeof TableCellFormat.HorizontalMergeEnum;
    "TableCellFormat.OrientationEnum": typeof TableCellFormat.OrientationEnum;
    "TableCellFormat.VerticalAlignmentEnum": typeof TableCellFormat.VerticalAlignmentEnum;
    "TableCellFormat.VerticalMergeEnum": typeof TableCellFormat.VerticalMergeEnum;
    "TableProperties.AlignmentEnum": typeof TableProperties.AlignmentEnum;
    "TableProperties.StyleIdentifierEnum": typeof TableProperties.StyleIdentifierEnum;
    "TableProperties.StyleOptionsEnum": typeof TableProperties.StyleOptionsEnum;
    "TableProperties.TextWrappingEnum": typeof TableProperties.TextWrappingEnum;
    "TableRowFormat.HeightRuleEnum": typeof TableRowFormat.HeightRuleEnum;
    "TextSaveOptionsData.ExportHeadersFootersModeEnum": typeof TextSaveOptionsData.ExportHeadersFootersModeEnum;
    "PdfSaveOptionsData.HeaderFooterBookmarksExportModeEnum": typeof PdfSaveOptionsData.HeaderFooterBookmarksExportModeEnum;
    "DrawingObject.RelativeHorizontalPositionEnum": typeof DrawingObject.RelativeHorizontalPositionEnum;
    "DrawingObject.RelativeVerticalPositionEnum": typeof DrawingObject.RelativeVerticalPositionEnum;
    "DrawingObject.WrapTypeEnum": typeof DrawingObject.WrapTypeEnum;
    "Footnote.FootnoteTypeEnum": typeof Footnote.FootnoteTypeEnum;
    "FormFieldTextInput.TextInputTypeEnum": typeof FormFieldTextInput.TextInputTypeEnum;
    "OfficeMathObject.DisplayTypeEnum": typeof OfficeMathObject.DisplayTypeEnum;
    "OfficeMathObject.JustificationEnum": typeof OfficeMathObject.JustificationEnum;
    "OfficeMathObject.MathObjectTypeEnum": typeof OfficeMathObject.MathObjectTypeEnum;
};
declare const typeMap: {
    ApiError: typeof ApiError;
    BookmarkData: typeof BookmarkData;
    BookmarksOutlineLevelData: typeof BookmarksOutlineLevelData;
    ClassificationResult: typeof ClassificationResult;
    CompareData: typeof CompareData;
    Document: typeof Document;
    DocumentEntry: typeof DocumentEntry;
    DocumentEntryList: typeof DocumentEntryList;
    DocumentPosition: typeof DocumentPosition;
    DocumentStatData: typeof DocumentStatData;
    DownsampleOptionsData: typeof DownsampleOptionsData;
    ErrorDetails: typeof ErrorDetails;
    FilesList: typeof FilesList;
    FilesUploadResult: typeof FilesUploadResult;
    FontInfo: typeof FontInfo;
    FootnotesStatData: typeof FootnotesStatData;
    GraphicsQualityOptionsData: typeof GraphicsQualityOptionsData;
    Link: typeof Link;
    LinkElement: typeof LinkElement;
    LoadWebDocumentData: typeof LoadWebDocumentData;
    MetafileRenderingOptionsData: typeof MetafileRenderingOptionsData;
    ModificationOperationResult: typeof ModificationOperationResult;
    OutlineOptionsData: typeof OutlineOptionsData;
    PageNumber: typeof PageNumber;
    PageStatData: typeof PageStatData;
    ParagraphInsert: typeof ParagraphInsert;
    PdfDigitalSignatureDetailsData: typeof PdfDigitalSignatureDetailsData;
    PdfEncryptionDetailsData: typeof PdfEncryptionDetailsData;
    PreferredWidth: typeof PreferredWidth;
    ProtectionData: typeof ProtectionData;
    ProtectionRequest: typeof ProtectionRequest;
    RangeDocument: typeof RangeDocument;
    ReplaceRange: typeof ReplaceRange;
    ReplaceTextParameters: typeof ReplaceTextParameters;
    SaveOptionsData: typeof SaveOptionsData;
    SaveResult: typeof SaveResult;
    SearchResult: typeof SearchResult;
    SplitDocumentResult: typeof SplitDocumentResult;
    StorageApiError: typeof StorageApiError;
    StorageFile: typeof StorageFile;
    StoryChildNodes: typeof StoryChildNodes;
    StringFormatData: typeof StringFormatData;
    TableCellInsert: typeof TableCellInsert;
    TableInsert: typeof TableInsert;
    TableRowInsert: typeof TableRowInsert;
    WatermarkText: typeof WatermarkText;
    WordsResponse: typeof WordsResponse;
    XmlColor: typeof XmlColor;
    AvailableFontsResponse: typeof AvailableFontsResponse;
    Bookmark: typeof Bookmark;
    BookmarkResponse: typeof BookmarkResponse;
    Bookmarks: typeof Bookmarks;
    BookmarksResponse: typeof BookmarksResponse;
    Border: typeof Border;
    BorderResponse: typeof BorderResponse;
    BordersCollection: typeof BordersCollection;
    BordersResponse: typeof BordersResponse;
    ClassificationResponse: typeof ClassificationResponse;
    CommentLink: typeof CommentLink;
    CommentResponse: typeof CommentResponse;
    CommentsCollection: typeof CommentsCollection;
    CommentsResponse: typeof CommentsResponse;
    DocSaveOptionsData: typeof DocSaveOptionsData;
    DocumentProperties: typeof DocumentProperties;
    DocumentPropertiesResponse: typeof DocumentPropertiesResponse;
    DocumentProperty: typeof DocumentProperty;
    DocumentPropertyResponse: typeof DocumentPropertyResponse;
    DocumentResponse: typeof DocumentResponse;
    DrawingObjectCollection: typeof DrawingObjectCollection;
    DrawingObjectResponse: typeof DrawingObjectResponse;
    DrawingObjectsResponse: typeof DrawingObjectsResponse;
    FieldCollection: typeof FieldCollection;
    FieldNames: typeof FieldNames;
    FieldNamesResponse: typeof FieldNamesResponse;
    FieldResponse: typeof FieldResponse;
    FieldsResponse: typeof FieldsResponse;
    FileLink: typeof FileLink;
    FixedPageSaveOptionsData: typeof FixedPageSaveOptionsData;
    Font: typeof Font;
    FontResponse: typeof FontResponse;
    FootnoteCollection: typeof FootnoteCollection;
    FootnoteResponse: typeof FootnoteResponse;
    FootnotesResponse: typeof FootnotesResponse;
    FormFieldCollection: typeof FormFieldCollection;
    FormFieldResponse: typeof FormFieldResponse;
    FormFieldsResponse: typeof FormFieldsResponse;
    HeaderFooterLink: typeof HeaderFooterLink;
    HeaderFooterLinkCollection: typeof HeaderFooterLinkCollection;
    HeaderFooterResponse: typeof HeaderFooterResponse;
    HeaderFootersResponse: typeof HeaderFootersResponse;
    HtmlSaveOptionsData: typeof HtmlSaveOptionsData;
    Hyperlink: typeof Hyperlink;
    HyperlinkResponse: typeof HyperlinkResponse;
    Hyperlinks: typeof Hyperlinks;
    HyperlinksResponse: typeof HyperlinksResponse;
    NodeLink: typeof NodeLink;
    OdtSaveOptionsData: typeof OdtSaveOptionsData;
    OfficeMathObjectResponse: typeof OfficeMathObjectResponse;
    OfficeMathObjectsCollection: typeof OfficeMathObjectsCollection;
    OfficeMathObjectsResponse: typeof OfficeMathObjectsResponse;
    OoxmlSaveOptionsData: typeof OoxmlSaveOptionsData;
    PageSetup: typeof PageSetup;
    ParagraphFormat: typeof ParagraphFormat;
    ParagraphFormatResponse: typeof ParagraphFormatResponse;
    ParagraphLinkCollection: typeof ParagraphLinkCollection;
    ParagraphLinkCollectionResponse: typeof ParagraphLinkCollectionResponse;
    ParagraphResponse: typeof ParagraphResponse;
    ProtectionDataResponse: typeof ProtectionDataResponse;
    RangeTextResponse: typeof RangeTextResponse;
    ReplaceTextResponse: typeof ReplaceTextResponse;
    RevisionsModificationResponse: typeof RevisionsModificationResponse;
    RtfSaveOptionsData: typeof RtfSaveOptionsData;
    RunResponse: typeof RunResponse;
    Runs: typeof Runs;
    RunsResponse: typeof RunsResponse;
    SaveResponse: typeof SaveResponse;
    SearchResponse: typeof SearchResponse;
    SearchResultsCollection: typeof SearchResultsCollection;
    Section: typeof Section;
    SectionLinkCollection: typeof SectionLinkCollection;
    SectionLinkCollectionResponse: typeof SectionLinkCollectionResponse;
    SectionPageSetupResponse: typeof SectionPageSetupResponse;
    SectionResponse: typeof SectionResponse;
    SplitDocumentResponse: typeof SplitDocumentResponse;
    StatDataResponse: typeof StatDataResponse;
    TableCellFormat: typeof TableCellFormat;
    TableCellFormatResponse: typeof TableCellFormatResponse;
    TableCellResponse: typeof TableCellResponse;
    TableLinkCollection: typeof TableLinkCollection;
    TableLinkCollectionResponse: typeof TableLinkCollectionResponse;
    TableProperties: typeof TableProperties;
    TablePropertiesResponse: typeof TablePropertiesResponse;
    TableResponse: typeof TableResponse;
    TableRowFormat: typeof TableRowFormat;
    TableRowFormatResponse: typeof TableRowFormatResponse;
    TableRowResponse: typeof TableRowResponse;
    TextSaveOptionsData: typeof TextSaveOptionsData;
    WordMLSaveOptionsData: typeof WordMLSaveOptionsData;
    WordsApiErrorResponse: typeof WordsApiErrorResponse;
    WordsApiLink: typeof WordsApiLink;
    XamlFlowSaveOptionsData: typeof XamlFlowSaveOptionsData;
    Comment: typeof Comment;
    DrawingObjectLink: typeof DrawingObjectLink;
    EpubSaveOptionsData: typeof EpubSaveOptionsData;
    FieldLink: typeof FieldLink;
    FootnoteLink: typeof FootnoteLink;
    FormField: typeof FormField;
    HeaderFooter: typeof HeaderFooter;
    HtmlFixedSaveOptionsData: typeof HtmlFixedSaveOptionsData;
    ImageSaveOptionsData: typeof ImageSaveOptionsData;
    MhtmlSaveOptionsData: typeof MhtmlSaveOptionsData;
    OfficeMathLink: typeof OfficeMathLink;
    Paragraph: typeof Paragraph;
    ParagraphLink: typeof ParagraphLink;
    PclSaveOptionsData: typeof PclSaveOptionsData;
    PdfSaveOptionsData: typeof PdfSaveOptionsData;
    PsSaveOptionsData: typeof PsSaveOptionsData;
    RunLink: typeof RunLink;
    SectionLink: typeof SectionLink;
    SvgSaveOptionsData: typeof SvgSaveOptionsData;
    Table: typeof Table;
    TableCell: typeof TableCell;
    TableLink: typeof TableLink;
    TableRow: typeof TableRow;
    XamlFixedSaveOptionsData: typeof XamlFixedSaveOptionsData;
    XpsSaveOptionsData: typeof XpsSaveOptionsData;
    BmpSaveOptionsData: typeof BmpSaveOptionsData;
    DrawingObject: typeof DrawingObject;
    EmfSaveOptionsData: typeof EmfSaveOptionsData;
    Field: typeof Field;
    Footnote: typeof Footnote;
    FormFieldCheckbox: typeof FormFieldCheckbox;
    FormFieldDropDown: typeof FormFieldDropDown;
    FormFieldTextInput: typeof FormFieldTextInput;
    GifSaveOptionsData: typeof GifSaveOptionsData;
    JpegSaveOptionsData: typeof JpegSaveOptionsData;
    OfficeMathObject: typeof OfficeMathObject;
    PngSaveOptionsData: typeof PngSaveOptionsData;
    Run: typeof Run;
    TiffSaveOptionsData: typeof TiffSaveOptionsData;
};
export { enumsMap, typeMap };
/**
 * Request model for AcceptAllRevisions operation.
 */
export declare class AcceptAllRevisionsRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    constructor(init?: Partial<AcceptAllRevisionsRequest>);
}
/**
 * Request model for AppendDocument operation.
 */
export declare class AppendDocumentRequest {
    /**
     * Original document name.
     */
    name: string;
    /**
     * with a list of documents to append.
     */
    documentList: DocumentEntryList;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    revisionAuthor: string;
    /**
     * The date and time to use for revisions.
     */
    revisionDateTime: string;
    constructor(init?: Partial<AppendDocumentRequest>);
}
/**
 * Request model for Classify operation.
 */
export declare class ClassifyRequest {
    /**
     * Text to classify.
     */
    text: string;
    /**
     * Number of the best classes to return.
     */
    bestClassesCount: string;
    constructor(init?: Partial<ClassifyRequest>);
}
/**
 * Request model for ClassifyDocument operation.
 */
export declare class ClassifyDocumentRequest {
    /**
     * The document name.
     */
    documentName: string;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Count of the best classes to return.
     */
    bestClassesCount: string;
    /**
     * Taxonomy to use for classification return.
     */
    taxonomy: string;
    constructor(init?: Partial<ClassifyDocumentRequest>);
}
/**
 * Request model for CompareDocument operation.
 */
export declare class CompareDocumentRequest {
    /**
     * Original document name.
     */
    name: string;
    /**
     * with a document to compare.
     */
    compareData: CompareData;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    constructor(init?: Partial<CompareDocumentRequest>);
}
/**
 * Request model for ConvertDocument operation.
 */
export declare class ConvertDocumentRequest {
    /**
     * Converting document
     */
    document: Readable;
    /**
     * Format to convert.
     */
    format: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Path for saving operation result to the local storage.
     */
    outPath: string;
    /**
     * This file name will be used when resulting document has dynamic field for document file name {filename}. If it is not set, \"sourceFilename\" will be used instead.
     */
    fileNameFieldValue: string;
    /**
     * Folder in filestorage with custom fonts.
     */
    fontsLocation: string;
    constructor(init?: Partial<ConvertDocumentRequest>);
}
/**
 * Request model for CopyFile operation.
 */
export declare class CopyFileRequest {
    /**
     * Destination file path
     */
    destPath: string;
    /**
     * Source file's path e.g. '/Folder 1/file.ext' or '/Bucket/Folder 1/file.ext'
     */
    srcPath: string;
    /**
     * Source storage name
     */
    srcStorageName: string;
    /**
     * Destination storage name
     */
    destStorageName: string;
    /**
     * File version ID to copy
     */
    versionId: string;
    constructor(init?: Partial<CopyFileRequest>);
}
/**
 * Request model for CopyFolder operation.
 */
export declare class CopyFolderRequest {
    /**
     * Destination folder path e.g. '/dst'
     */
    destPath: string;
    /**
     * Source folder path e.g. /Folder1
     */
    srcPath: string;
    /**
     * Source storage name
     */
    srcStorageName: string;
    /**
     * Destination storage name
     */
    destStorageName: string;
    constructor(init?: Partial<CopyFolderRequest>);
}
/**
 * Request model for CreateDocument operation.
 */
export declare class CreateDocumentRequest {
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * The document name.
     */
    fileName: string;
    /**
     * The document folder.
     */
    folder: string;
    constructor(init?: Partial<CreateDocumentRequest>);
}
/**
 * Request model for CreateFolder operation.
 */
export declare class CreateFolderRequest {
    /**
     * Target folder's path e.g. Folder1/Folder2/. The folders will be created recursively
     */
    path: string;
    /**
     * Storage name
     */
    storageName: string;
    constructor(init?: Partial<CreateFolderRequest>);
}
/**
 * Request model for CreateOrUpdateDocumentProperty operation.
 */
export declare class CreateOrUpdateDocumentPropertyRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * The property name.
     */
    propertyName: string;
    /**
     * The property with new value.
     */
    property: DocumentProperty;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    revisionAuthor: string;
    /**
     * The date and time to use for revisions.
     */
    revisionDateTime: string;
    constructor(init?: Partial<CreateOrUpdateDocumentPropertyRequest>);
}
/**
 * Request model for DeleteBorder operation.
 */
export declare class DeleteBorderRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Path to the node with border(node should be paragraph, cell or row).
     */
    nodePath: string;
    /**
     * Border type.
     */
    borderType: 'Bottom' | 'Left' | 'Right' | 'Top' | 'Horizontal' | 'Vertical' | 'DiagonalDown' | 'DiagonalUp' | 'None';
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    revisionAuthor: string;
    /**
     * The date and time to use for revisions.
     */
    revisionDateTime: string;
    constructor(init?: Partial<DeleteBorderRequest>);
}
/**
 * Request model for DeleteBorders operation.
 */
export declare class DeleteBordersRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Path to the node with borders(node should be paragraph, cell or row).
     */
    nodePath: string;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    revisionAuthor: string;
    /**
     * The date and time to use for revisions.
     */
    revisionDateTime: string;
    constructor(init?: Partial<DeleteBordersRequest>);
}
/**
 * Request model for DeleteComment operation.
 */
export declare class DeleteCommentRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * The comment index.
     */
    commentIndex: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    revisionAuthor: string;
    /**
     * The date and time to use for revisions.
     */
    revisionDateTime: string;
    constructor(init?: Partial<DeleteCommentRequest>);
}
/**
 * Request model for DeleteDocumentProperty operation.
 */
export declare class DeleteDocumentPropertyRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * The property name.
     */
    propertyName: string;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    revisionAuthor: string;
    /**
     * The date and time to use for revisions.
     */
    revisionDateTime: string;
    constructor(init?: Partial<DeleteDocumentPropertyRequest>);
}
/**
 * Request model for DeleteDrawingObject operation.
 */
export declare class DeleteDrawingObjectRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Path to the node, which contains collection of drawing objects.
     */
    nodePath: string;
    /**
     * Object index.
     */
    index: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    revisionAuthor: string;
    /**
     * The date and time to use for revisions.
     */
    revisionDateTime: string;
    constructor(init?: Partial<DeleteDrawingObjectRequest>);
}
/**
 * Request model for DeleteDrawingObjectWithoutNodePath operation.
 */
export declare class DeleteDrawingObjectWithoutNodePathRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Object index.
     */
    index: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    revisionAuthor: string;
    /**
     * The date and time to use for revisions.
     */
    revisionDateTime: string;
    constructor(init?: Partial<DeleteDrawingObjectWithoutNodePathRequest>);
}
/**
 * Request model for DeleteField operation.
 */
export declare class DeleteFieldRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Path to the node, which contains collection of fields.
     */
    nodePath: string;
    /**
     * Object index.
     */
    index: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    revisionAuthor: string;
    /**
     * The date and time to use for revisions.
     */
    revisionDateTime: string;
    constructor(init?: Partial<DeleteFieldRequest>);
}
/**
 * Request model for DeleteFieldWithoutNodePath operation.
 */
export declare class DeleteFieldWithoutNodePathRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Object index.
     */
    index: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    revisionAuthor: string;
    /**
     * The date and time to use for revisions.
     */
    revisionDateTime: string;
    constructor(init?: Partial<DeleteFieldWithoutNodePathRequest>);
}
/**
 * Request model for DeleteFields operation.
 */
export declare class DeleteFieldsRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Path to the node, which contains collection of fields.
     */
    nodePath: string;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    revisionAuthor: string;
    /**
     * The date and time to use for revisions.
     */
    revisionDateTime: string;
    constructor(init?: Partial<DeleteFieldsRequest>);
}
/**
 * Request model for DeleteFieldsWithoutNodePath operation.
 */
export declare class DeleteFieldsWithoutNodePathRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    revisionAuthor: string;
    /**
     * The date and time to use for revisions.
     */
    revisionDateTime: string;
    constructor(init?: Partial<DeleteFieldsWithoutNodePathRequest>);
}
/**
 * Request model for DeleteFile operation.
 */
export declare class DeleteFileRequest {
    /**
     * Path of the file including file name and extension e.g. /Folder1/file.ext
     */
    path: string;
    /**
     * Storage name
     */
    storageName: string;
    /**
     * File version ID to delete
     */
    versionId: string;
    constructor(init?: Partial<DeleteFileRequest>);
}
/**
 * Request model for DeleteFolder operation.
 */
export declare class DeleteFolderRequest {
    /**
     * Folder path e.g. /Folder1s
     */
    path: string;
    /**
     * Storage name
     */
    storageName: string;
    /**
     * Enable to delete folders, subfolders and files
     */
    recursive: boolean;
    constructor(init?: Partial<DeleteFolderRequest>);
}
/**
 * Request model for DeleteFootnote operation.
 */
export declare class DeleteFootnoteRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Path to the node, which contains collection of footnotes.
     */
    nodePath: string;
    /**
     * Object index.
     */
    index: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    revisionAuthor: string;
    /**
     * The date and time to use for revisions.
     */
    revisionDateTime: string;
    constructor(init?: Partial<DeleteFootnoteRequest>);
}
/**
 * Request model for DeleteFootnoteWithoutNodePath operation.
 */
export declare class DeleteFootnoteWithoutNodePathRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Object index.
     */
    index: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    revisionAuthor: string;
    /**
     * The date and time to use for revisions.
     */
    revisionDateTime: string;
    constructor(init?: Partial<DeleteFootnoteWithoutNodePathRequest>);
}
/**
 * Request model for DeleteFormField operation.
 */
export declare class DeleteFormFieldRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Path to the node that contains collection of formfields.
     */
    nodePath: string;
    /**
     * Object index.
     */
    index: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    revisionAuthor: string;
    /**
     * The date and time to use for revisions.
     */
    revisionDateTime: string;
    constructor(init?: Partial<DeleteFormFieldRequest>);
}
/**
 * Request model for DeleteFormFieldWithoutNodePath operation.
 */
export declare class DeleteFormFieldWithoutNodePathRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Object index.
     */
    index: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    revisionAuthor: string;
    /**
     * The date and time to use for revisions.
     */
    revisionDateTime: string;
    constructor(init?: Partial<DeleteFormFieldWithoutNodePathRequest>);
}
/**
 * Request model for DeleteHeaderFooter operation.
 */
export declare class DeleteHeaderFooterRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Path to parent section.
     */
    sectionPath: string;
    /**
     * Object index.
     */
    index: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    revisionAuthor: string;
    /**
     * The date and time to use for revisions.
     */
    revisionDateTime: string;
    constructor(init?: Partial<DeleteHeaderFooterRequest>);
}
/**
 * Request model for DeleteHeadersFooters operation.
 */
export declare class DeleteHeadersFootersRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Path to parent section.
     */
    sectionPath: string;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    revisionAuthor: string;
    /**
     * The date and time to use for revisions.
     */
    revisionDateTime: string;
    /**
     * List of types of headers and footers.
     */
    headersFootersTypes: string;
    constructor(init?: Partial<DeleteHeadersFootersRequest>);
}
/**
 * Request model for DeleteMacros operation.
 */
export declare class DeleteMacrosRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    revisionAuthor: string;
    /**
     * The date and time to use for revisions.
     */
    revisionDateTime: string;
    constructor(init?: Partial<DeleteMacrosRequest>);
}
/**
 * Request model for DeleteOfficeMathObject operation.
 */
export declare class DeleteOfficeMathObjectRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Path to the node, which contains collection of OfficeMath objects.
     */
    nodePath: string;
    /**
     * Object index.
     */
    index: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    revisionAuthor: string;
    /**
     * The date and time to use for revisions.
     */
    revisionDateTime: string;
    constructor(init?: Partial<DeleteOfficeMathObjectRequest>);
}
/**
 * Request model for DeleteOfficeMathObjectWithoutNodePath operation.
 */
export declare class DeleteOfficeMathObjectWithoutNodePathRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Object index.
     */
    index: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    revisionAuthor: string;
    /**
     * The date and time to use for revisions.
     */
    revisionDateTime: string;
    constructor(init?: Partial<DeleteOfficeMathObjectWithoutNodePathRequest>);
}
/**
 * Request model for DeleteParagraph operation.
 */
export declare class DeleteParagraphRequest {
    /**
     * The file name.
     */
    name: string;
    /**
     * Path to the node which contains paragraphs.
     */
    nodePath: string;
    /**
     * Object index.
     */
    index: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    revisionAuthor: string;
    /**
     * The date and time to use for revisions.
     */
    revisionDateTime: string;
    constructor(init?: Partial<DeleteParagraphRequest>);
}
/**
 * Request model for DeleteParagraphWithoutNodePath operation.
 */
export declare class DeleteParagraphWithoutNodePathRequest {
    /**
     * The file name.
     */
    name: string;
    /**
     * Object index.
     */
    index: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    revisionAuthor: string;
    /**
     * The date and time to use for revisions.
     */
    revisionDateTime: string;
    constructor(init?: Partial<DeleteParagraphWithoutNodePathRequest>);
}
/**
 * Request model for DeleteRun operation.
 */
export declare class DeleteRunRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Path to parent paragraph.
     */
    paragraphPath: string;
    /**
     * Object index.
     */
    index: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    revisionAuthor: string;
    /**
     * The date and time to use for revisions.
     */
    revisionDateTime: string;
    constructor(init?: Partial<DeleteRunRequest>);
}
/**
 * Request model for DeleteSection operation.
 */
export declare class DeleteSectionRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Section index.
     */
    sectionIndex: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    revisionAuthor: string;
    /**
     * The date and time to use for revisions.
     */
    revisionDateTime: string;
    constructor(init?: Partial<DeleteSectionRequest>);
}
/**
 * Request model for DeleteTable operation.
 */
export declare class DeleteTableRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Path to the node, which contains tables.
     */
    nodePath: string;
    /**
     * Object index.
     */
    index: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    revisionAuthor: string;
    /**
     * The date and time to use for revisions.
     */
    revisionDateTime: string;
    constructor(init?: Partial<DeleteTableRequest>);
}
/**
 * Request model for DeleteTableCell operation.
 */
export declare class DeleteTableCellRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Path to table row.
     */
    tableRowPath: string;
    /**
     * Object index.
     */
    index: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    revisionAuthor: string;
    /**
     * The date and time to use for revisions.
     */
    revisionDateTime: string;
    constructor(init?: Partial<DeleteTableCellRequest>);
}
/**
 * Request model for DeleteTableRow operation.
 */
export declare class DeleteTableRowRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Path to table.
     */
    tablePath: string;
    /**
     * Object index.
     */
    index: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    revisionAuthor: string;
    /**
     * The date and time to use for revisions.
     */
    revisionDateTime: string;
    constructor(init?: Partial<DeleteTableRowRequest>);
}
/**
 * Request model for DeleteTableWithoutNodePath operation.
 */
export declare class DeleteTableWithoutNodePathRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Object index.
     */
    index: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    revisionAuthor: string;
    /**
     * The date and time to use for revisions.
     */
    revisionDateTime: string;
    constructor(init?: Partial<DeleteTableWithoutNodePathRequest>);
}
/**
 * Request model for DeleteWatermark operation.
 */
export declare class DeleteWatermarkRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    revisionAuthor: string;
    /**
     * The date and time to use for revisions.
     */
    revisionDateTime: string;
    constructor(init?: Partial<DeleteWatermarkRequest>);
}
/**
 * Request model for DownloadFile operation.
 */
export declare class DownloadFileRequest {
    /**
     * Path of the file including the file name and extension e.g. /folder1/file.ext
     */
    path: string;
    /**
     * Storage name
     */
    storageName: string;
    /**
     * File version ID to download
     */
    versionId: string;
    constructor(init?: Partial<DownloadFileRequest>);
}
/**
 * Request model for ExecuteMailMerge operation.
 */
export declare class ExecuteMailMergeRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Mail merge data
     */
    data: string;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * With regions flag.
     */
    withRegions: boolean;
    /**
     * Mail merge data.
     */
    mailMergeDataFile: string;
    /**
     * Clean up options.
     */
    cleanup: string;
    /**
     * Gets or sets a value indicating whether paragraph with TableStart or             TableEnd field should be fully included into mail merge region or particular range between TableStart and TableEnd fields.             The default value is true.
     */
    useWholeParagraphAsRegion: boolean;
    /**
     * Result name of the document after the operation. If this parameter is omitted then result of the operation will be saved with autogenerated name.
     */
    destFileName: string;
    constructor(init?: Partial<ExecuteMailMergeRequest>);
}
/**
 * Request model for ExecuteMailMergeOnline operation.
 */
export declare class ExecuteMailMergeOnlineRequest {
    /**
     * File with template
     */
    template: Readable;
    /**
     * File with mailmerge data
     */
    data: Readable;
    /**
     * With regions flag.
     */
    withRegions: boolean;
    /**
     * Clean up options.
     */
    cleanup: string;
    /**
     * This file name will be used when resulting document has dynamic field for document file name {filename}. If it is not setted, \"template\" will be used instead.
     */
    documentFileName: string;
    constructor(init?: Partial<ExecuteMailMergeOnlineRequest>);
}
/**
 * Request model for GetAvailableFonts operation.
 */
export declare class GetAvailableFontsRequest {
    /**
     * Folder in filestorage with custom fonts.
     */
    fontsLocation: string;
    constructor(init?: Partial<GetAvailableFontsRequest>);
}
/**
 * Request model for GetBookmarkByName operation.
 */
export declare class GetBookmarkByNameRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * The bookmark name.
     */
    bookmarkName: string;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    constructor(init?: Partial<GetBookmarkByNameRequest>);
}
/**
 * Request model for GetBookmarks operation.
 */
export declare class GetBookmarksRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    constructor(init?: Partial<GetBookmarksRequest>);
}
/**
 * Request model for GetBorder operation.
 */
export declare class GetBorderRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Path to the node with border(node should be paragraph, cell or row).
     */
    nodePath: string;
    /**
     * Border type.
     */
    borderType: 'Bottom' | 'Left' | 'Right' | 'Top' | 'Horizontal' | 'Vertical' | 'DiagonalDown' | 'DiagonalUp' | 'None';
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    constructor(init?: Partial<GetBorderRequest>);
}
/**
 * Request model for GetBorders operation.
 */
export declare class GetBordersRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Path to the node with borders (node should be paragraph, cell or row).
     */
    nodePath: string;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    constructor(init?: Partial<GetBordersRequest>);
}
/**
 * Request model for GetComment operation.
 */
export declare class GetCommentRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * The comment index.
     */
    commentIndex: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    constructor(init?: Partial<GetCommentRequest>);
}
/**
 * Request model for GetComments operation.
 */
export declare class GetCommentsRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    constructor(init?: Partial<GetCommentsRequest>);
}
/**
 * Request model for GetDocument operation.
 */
export declare class GetDocumentRequest {
    /**
     * The document name.
     */
    documentName: string;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    constructor(init?: Partial<GetDocumentRequest>);
}
/**
 * Request model for GetDocumentDrawingObjectByIndex operation.
 */
export declare class GetDocumentDrawingObjectByIndexRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Path to the node, which contains collection of drawing objects.
     */
    nodePath: string;
    /**
     * Object index.
     */
    index: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    constructor(init?: Partial<GetDocumentDrawingObjectByIndexRequest>);
}
/**
 * Request model for GetDocumentDrawingObjectByIndexWithoutNodePath operation.
 */
export declare class GetDocumentDrawingObjectByIndexWithoutNodePathRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Object index.
     */
    index: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    constructor(init?: Partial<GetDocumentDrawingObjectByIndexWithoutNodePathRequest>);
}
/**
 * Request model for GetDocumentDrawingObjectImageData operation.
 */
export declare class GetDocumentDrawingObjectImageDataRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Path to the node, which contains collection of drawing objects.
     */
    nodePath: string;
    /**
     * Object index.
     */
    index: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    constructor(init?: Partial<GetDocumentDrawingObjectImageDataRequest>);
}
/**
 * Request model for GetDocumentDrawingObjectImageDataWithoutNodePath operation.
 */
export declare class GetDocumentDrawingObjectImageDataWithoutNodePathRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Object index.
     */
    index: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    constructor(init?: Partial<GetDocumentDrawingObjectImageDataWithoutNodePathRequest>);
}
/**
 * Request model for GetDocumentDrawingObjectOleData operation.
 */
export declare class GetDocumentDrawingObjectOleDataRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Path to the node, which contains collection of drawing objects.
     */
    nodePath: string;
    /**
     * Object index.
     */
    index: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    constructor(init?: Partial<GetDocumentDrawingObjectOleDataRequest>);
}
/**
 * Request model for GetDocumentDrawingObjectOleDataWithoutNodePath operation.
 */
export declare class GetDocumentDrawingObjectOleDataWithoutNodePathRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Object index.
     */
    index: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    constructor(init?: Partial<GetDocumentDrawingObjectOleDataWithoutNodePathRequest>);
}
/**
 * Request model for GetDocumentDrawingObjects operation.
 */
export declare class GetDocumentDrawingObjectsRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Path to the node, which contains collection of drawing objects.
     */
    nodePath: string;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    constructor(init?: Partial<GetDocumentDrawingObjectsRequest>);
}
/**
 * Request model for GetDocumentDrawingObjectsWithoutNodePath operation.
 */
export declare class GetDocumentDrawingObjectsWithoutNodePathRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    constructor(init?: Partial<GetDocumentDrawingObjectsWithoutNodePathRequest>);
}
/**
 * Request model for GetDocumentFieldNames operation.
 */
export declare class GetDocumentFieldNamesRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * If true, result includes \"mustache\" field names.
     */
    useNonMergeFields: boolean;
    constructor(init?: Partial<GetDocumentFieldNamesRequest>);
}
/**
 * Request model for GetDocumentFieldNamesOnline operation.
 */
export declare class GetDocumentFieldNamesOnlineRequest {
    /**
     * File with template
     */
    template: Readable;
    /**
     * Use non merge fields or not.
     */
    useNonMergeFields: boolean;
    constructor(init?: Partial<GetDocumentFieldNamesOnlineRequest>);
}
/**
 * Request model for GetDocumentHyperlinkByIndex operation.
 */
export declare class GetDocumentHyperlinkByIndexRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * The hyperlink index.
     */
    hyperlinkIndex: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    constructor(init?: Partial<GetDocumentHyperlinkByIndexRequest>);
}
/**
 * Request model for GetDocumentHyperlinks operation.
 */
export declare class GetDocumentHyperlinksRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    constructor(init?: Partial<GetDocumentHyperlinksRequest>);
}
/**
 * Request model for GetDocumentProperties operation.
 */
export declare class GetDocumentPropertiesRequest {
    /**
     * The document's name.
     */
    name: string;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    constructor(init?: Partial<GetDocumentPropertiesRequest>);
}
/**
 * Request model for GetDocumentProperty operation.
 */
export declare class GetDocumentPropertyRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * The property name.
     */
    propertyName: string;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    constructor(init?: Partial<GetDocumentPropertyRequest>);
}
/**
 * Request model for GetDocumentProtection operation.
 */
export declare class GetDocumentProtectionRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    constructor(init?: Partial<GetDocumentProtectionRequest>);
}
/**
 * Request model for GetDocumentStatistics operation.
 */
export declare class GetDocumentStatisticsRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Support including/excluding comments from the WordCount. Default value is \"false\".
     */
    includeComments: boolean;
    /**
     * Support including/excluding footnotes from the WordCount. Default value is \"false\".
     */
    includeFootnotes: boolean;
    /**
     * Support including/excluding shape's text from the WordCount. Default value is \"false\".
     */
    includeTextInShapes: boolean;
    constructor(init?: Partial<GetDocumentStatisticsRequest>);
}
/**
 * Request model for GetDocumentWithFormat operation.
 */
export declare class GetDocumentWithFormatRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * The destination format.
     */
    format: string;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Path to save the result.
     */
    outPath: string;
    /**
     * Folder in filestorage with custom fonts.
     */
    fontsLocation: string;
    constructor(init?: Partial<GetDocumentWithFormatRequest>);
}
/**
 * Request model for GetField operation.
 */
export declare class GetFieldRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Path to the node, which contains collection of fields.
     */
    nodePath: string;
    /**
     * Object index.
     */
    index: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    constructor(init?: Partial<GetFieldRequest>);
}
/**
 * Request model for GetFieldWithoutNodePath operation.
 */
export declare class GetFieldWithoutNodePathRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Object index.
     */
    index: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    constructor(init?: Partial<GetFieldWithoutNodePathRequest>);
}
/**
 * Request model for GetFields operation.
 */
export declare class GetFieldsRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Path to the node, which contains collection of fields.
     */
    nodePath: string;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    constructor(init?: Partial<GetFieldsRequest>);
}
/**
 * Request model for GetFieldsWithoutNodePath operation.
 */
export declare class GetFieldsWithoutNodePathRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    constructor(init?: Partial<GetFieldsWithoutNodePathRequest>);
}
/**
 * Request model for GetFilesList operation.
 */
export declare class GetFilesListRequest {
    /**
     * Folder path e.g. /Folder1
     */
    path: string;
    /**
     * Storage name
     */
    storageName: string;
    constructor(init?: Partial<GetFilesListRequest>);
}
/**
 * Request model for GetFootnote operation.
 */
export declare class GetFootnoteRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Path to the node, which contains collection of footnotes.
     */
    nodePath: string;
    /**
     * Object index.
     */
    index: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    constructor(init?: Partial<GetFootnoteRequest>);
}
/**
 * Request model for GetFootnoteWithoutNodePath operation.
 */
export declare class GetFootnoteWithoutNodePathRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Object index.
     */
    index: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    constructor(init?: Partial<GetFootnoteWithoutNodePathRequest>);
}
/**
 * Request model for GetFootnotes operation.
 */
export declare class GetFootnotesRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Path to the node, which contains collection of footnotes.
     */
    nodePath: string;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    constructor(init?: Partial<GetFootnotesRequest>);
}
/**
 * Request model for GetFootnotesWithoutNodePath operation.
 */
export declare class GetFootnotesWithoutNodePathRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    constructor(init?: Partial<GetFootnotesWithoutNodePathRequest>);
}
/**
 * Request model for GetFormField operation.
 */
export declare class GetFormFieldRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Path to the node that contains collection of formfields.
     */
    nodePath: string;
    /**
     * Object index.
     */
    index: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    constructor(init?: Partial<GetFormFieldRequest>);
}
/**
 * Request model for GetFormFieldWithoutNodePath operation.
 */
export declare class GetFormFieldWithoutNodePathRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Object index.
     */
    index: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    constructor(init?: Partial<GetFormFieldWithoutNodePathRequest>);
}
/**
 * Request model for GetFormFields operation.
 */
export declare class GetFormFieldsRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Path to the node containing collection of form fields.
     */
    nodePath: string;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    constructor(init?: Partial<GetFormFieldsRequest>);
}
/**
 * Request model for GetFormFieldsWithoutNodePath operation.
 */
export declare class GetFormFieldsWithoutNodePathRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    constructor(init?: Partial<GetFormFieldsWithoutNodePathRequest>);
}
/**
 * Request model for GetHeaderFooter operation.
 */
export declare class GetHeaderFooterRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Header/footer index.
     */
    headerFooterIndex: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * List of types of headers and footers.
     */
    filterByType: string;
    constructor(init?: Partial<GetHeaderFooterRequest>);
}
/**
 * Request model for GetHeaderFooterOfSection operation.
 */
export declare class GetHeaderFooterOfSectionRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Header/footer index.
     */
    headerFooterIndex: number;
    /**
     * Section index.
     */
    sectionIndex: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * List of types of headers and footers.
     */
    filterByType: string;
    constructor(init?: Partial<GetHeaderFooterOfSectionRequest>);
}
/**
 * Request model for GetHeaderFooters operation.
 */
export declare class GetHeaderFootersRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Path to parent section.
     */
    sectionPath: string;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * List of types of headers and footers.
     */
    filterByType: string;
    constructor(init?: Partial<GetHeaderFootersRequest>);
}
/**
 * Request model for GetOfficeMathObject operation.
 */
export declare class GetOfficeMathObjectRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Path to the node, which contains collection of OfficeMath objects.
     */
    nodePath: string;
    /**
     * Object index.
     */
    index: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    constructor(init?: Partial<GetOfficeMathObjectRequest>);
}
/**
 * Request model for GetOfficeMathObjectWithoutNodePath operation.
 */
export declare class GetOfficeMathObjectWithoutNodePathRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Object index.
     */
    index: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    constructor(init?: Partial<GetOfficeMathObjectWithoutNodePathRequest>);
}
/**
 * Request model for GetOfficeMathObjects operation.
 */
export declare class GetOfficeMathObjectsRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Path to the node, which contains collection of OfficeMath objects.
     */
    nodePath: string;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    constructor(init?: Partial<GetOfficeMathObjectsRequest>);
}
/**
 * Request model for GetOfficeMathObjectsWithoutNodePath operation.
 */
export declare class GetOfficeMathObjectsWithoutNodePathRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    constructor(init?: Partial<GetOfficeMathObjectsWithoutNodePathRequest>);
}
/**
 * Request model for GetParagraph operation.
 */
export declare class GetParagraphRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Path to the node which contains paragraphs.
     */
    nodePath: string;
    /**
     * Object index.
     */
    index: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    constructor(init?: Partial<GetParagraphRequest>);
}
/**
 * Request model for GetParagraphFormat operation.
 */
export declare class GetParagraphFormatRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Path to the node which contains paragraphs.
     */
    nodePath: string;
    /**
     * Object index.
     */
    index: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    constructor(init?: Partial<GetParagraphFormatRequest>);
}
/**
 * Request model for GetParagraphFormatWithoutNodePath operation.
 */
export declare class GetParagraphFormatWithoutNodePathRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Object index.
     */
    index: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    constructor(init?: Partial<GetParagraphFormatWithoutNodePathRequest>);
}
/**
 * Request model for GetParagraphWithoutNodePath operation.
 */
export declare class GetParagraphWithoutNodePathRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Object index.
     */
    index: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    constructor(init?: Partial<GetParagraphWithoutNodePathRequest>);
}
/**
 * Request model for GetParagraphs operation.
 */
export declare class GetParagraphsRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Path to the node which contains paragraphs.
     */
    nodePath: string;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    constructor(init?: Partial<GetParagraphsRequest>);
}
/**
 * Request model for GetParagraphsWithoutNodePath operation.
 */
export declare class GetParagraphsWithoutNodePathRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    constructor(init?: Partial<GetParagraphsWithoutNodePathRequest>);
}
/**
 * Request model for GetRangeText operation.
 */
export declare class GetRangeTextRequest {
    /**
     * The document.
     */
    name: string;
    /**
     * The range start identifier. Identifier is the value of the \"nodeId\" field, which every document node has, extended with the prefix \"id\". It looks like \"id0.0.7\". Also values like \"image5\" and \"table3\" can be used as an identifier for images and tables, where the number is an index of the image/table.
     */
    rangeStartIdentifier: string;
    /**
     * The range end identifier.
     */
    rangeEndIdentifier: string;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    constructor(init?: Partial<GetRangeTextRequest>);
}
/**
 * Request model for GetRun operation.
 */
export declare class GetRunRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Path to parent paragraph.
     */
    paragraphPath: string;
    /**
     * Object index.
     */
    index: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    constructor(init?: Partial<GetRunRequest>);
}
/**
 * Request model for GetRunFont operation.
 */
export declare class GetRunFontRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Path to parent paragraph.
     */
    paragraphPath: string;
    /**
     * Object index.
     */
    index: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    constructor(init?: Partial<GetRunFontRequest>);
}
/**
 * Request model for GetRuns operation.
 */
export declare class GetRunsRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Path to parent paragraph.
     */
    paragraphPath: string;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    constructor(init?: Partial<GetRunsRequest>);
}
/**
 * Request model for GetSection operation.
 */
export declare class GetSectionRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Section index.
     */
    sectionIndex: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    constructor(init?: Partial<GetSectionRequest>);
}
/**
 * Request model for GetSectionPageSetup operation.
 */
export declare class GetSectionPageSetupRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Section index.
     */
    sectionIndex: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    constructor(init?: Partial<GetSectionPageSetupRequest>);
}
/**
 * Request model for GetSections operation.
 */
export declare class GetSectionsRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    constructor(init?: Partial<GetSectionsRequest>);
}
/**
 * Request model for GetTable operation.
 */
export declare class GetTableRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Path to the node, which contains tables.
     */
    nodePath: string;
    /**
     * Object index.
     */
    index: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    constructor(init?: Partial<GetTableRequest>);
}
/**
 * Request model for GetTableCell operation.
 */
export declare class GetTableCellRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Path to table row.
     */
    tableRowPath: string;
    /**
     * Object index.
     */
    index: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    constructor(init?: Partial<GetTableCellRequest>);
}
/**
 * Request model for GetTableCellFormat operation.
 */
export declare class GetTableCellFormatRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Path to table row.
     */
    tableRowPath: string;
    /**
     * Object index.
     */
    index: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    constructor(init?: Partial<GetTableCellFormatRequest>);
}
/**
 * Request model for GetTableProperties operation.
 */
export declare class GetTablePropertiesRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Path to the node, which contains tables.
     */
    nodePath: string;
    /**
     * Object index.
     */
    index: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    constructor(init?: Partial<GetTablePropertiesRequest>);
}
/**
 * Request model for GetTablePropertiesWithoutNodePath operation.
 */
export declare class GetTablePropertiesWithoutNodePathRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Object index.
     */
    index: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    constructor(init?: Partial<GetTablePropertiesWithoutNodePathRequest>);
}
/**
 * Request model for GetTableRow operation.
 */
export declare class GetTableRowRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Path to table.
     */
    tablePath: string;
    /**
     * Object index.
     */
    index: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    constructor(init?: Partial<GetTableRowRequest>);
}
/**
 * Request model for GetTableRowFormat operation.
 */
export declare class GetTableRowFormatRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Path to table.
     */
    tablePath: string;
    /**
     * Object index.
     */
    index: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    constructor(init?: Partial<GetTableRowFormatRequest>);
}
/**
 * Request model for GetTableWithoutNodePath operation.
 */
export declare class GetTableWithoutNodePathRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Object index.
     */
    index: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    constructor(init?: Partial<GetTableWithoutNodePathRequest>);
}
/**
 * Request model for GetTables operation.
 */
export declare class GetTablesRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Path to the node, which contains tables.
     */
    nodePath: string;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    constructor(init?: Partial<GetTablesRequest>);
}
/**
 * Request model for GetTablesWithoutNodePath operation.
 */
export declare class GetTablesWithoutNodePathRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    constructor(init?: Partial<GetTablesWithoutNodePathRequest>);
}
/**
 * Request model for InsertComment operation.
 */
export declare class InsertCommentRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * The comment data.
     */
    comment: Comment;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    revisionAuthor: string;
    /**
     * The date and time to use for revisions.
     */
    revisionDateTime: string;
    constructor(init?: Partial<InsertCommentRequest>);
}
/**
 * Request model for InsertDrawingObject operation.
 */
export declare class InsertDrawingObjectRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Drawing object parameters
     */
    drawingObject: string;
    /**
     * File with image
     */
    imageFile: Readable;
    /**
     * Path to the node, which contains collection of drawing objects.
     */
    nodePath: string;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    revisionAuthor: string;
    /**
     * The date and time to use for revisions.
     */
    revisionDateTime: string;
    constructor(init?: Partial<InsertDrawingObjectRequest>);
}
/**
 * Request model for InsertDrawingObjectWithoutNodePath operation.
 */
export declare class InsertDrawingObjectWithoutNodePathRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Drawing object parameters
     */
    drawingObject: string;
    /**
     * File with image
     */
    imageFile: Readable;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    revisionAuthor: string;
    /**
     * The date and time to use for revisions.
     */
    revisionDateTime: string;
    constructor(init?: Partial<InsertDrawingObjectWithoutNodePathRequest>);
}
/**
 * Request model for InsertField operation.
 */
export declare class InsertFieldRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Field data.
     */
    field: Field;
    /**
     * Path to the node, which contains collection of fields.
     */
    nodePath: string;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    revisionAuthor: string;
    /**
     * The date and time to use for revisions.
     */
    revisionDateTime: string;
    /**
     * Field will be inserted before node with id=\"nodeId\".
     */
    insertBeforeNode: string;
    constructor(init?: Partial<InsertFieldRequest>);
}
/**
 * Request model for InsertFieldWithoutNodePath operation.
 */
export declare class InsertFieldWithoutNodePathRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Field data.
     */
    field: Field;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    revisionAuthor: string;
    /**
     * The date and time to use for revisions.
     */
    revisionDateTime: string;
    /**
     * Field will be inserted before node with id=\"nodeId\".
     */
    insertBeforeNode: string;
    constructor(init?: Partial<InsertFieldWithoutNodePathRequest>);
}
/**
 * Request model for InsertFootnote operation.
 */
export declare class InsertFootnoteRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Footnote data.
     */
    footnoteDto: Footnote;
    /**
     * Path to the node, which contains collection of footnotes.
     */
    nodePath: string;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    revisionAuthor: string;
    /**
     * The date and time to use for revisions.
     */
    revisionDateTime: string;
    constructor(init?: Partial<InsertFootnoteRequest>);
}
/**
 * Request model for InsertFootnoteWithoutNodePath operation.
 */
export declare class InsertFootnoteWithoutNodePathRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Footnote data.
     */
    footnoteDto: Footnote;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    revisionAuthor: string;
    /**
     * The date and time to use for revisions.
     */
    revisionDateTime: string;
    constructor(init?: Partial<InsertFootnoteWithoutNodePathRequest>);
}
/**
 * Request model for InsertFormField operation.
 */
export declare class InsertFormFieldRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * From field data.
     */
    formField: FormField;
    /**
     * Path to the node that contains collection of formfields.
     */
    nodePath: string;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    revisionAuthor: string;
    /**
     * The date and time to use for revisions.
     */
    revisionDateTime: string;
    /**
     * Form field will be inserted before node with index.
     */
    insertBeforeNode: string;
    constructor(init?: Partial<InsertFormFieldRequest>);
}
/**
 * Request model for InsertFormFieldWithoutNodePath operation.
 */
export declare class InsertFormFieldWithoutNodePathRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * From field data.
     */
    formField: FormField;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    revisionAuthor: string;
    /**
     * The date and time to use for revisions.
     */
    revisionDateTime: string;
    /**
     * Form field will be inserted before node with index.
     */
    insertBeforeNode: string;
    constructor(init?: Partial<InsertFormFieldWithoutNodePathRequest>);
}
/**
 * Request model for InsertHeaderFooter operation.
 */
export declare class InsertHeaderFooterRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Type of header/footer.
     */
    headerFooterType: string;
    /**
     * Path to parent section.
     */
    sectionPath: string;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    revisionAuthor: string;
    /**
     * The date and time to use for revisions.
     */
    revisionDateTime: string;
    constructor(init?: Partial<InsertHeaderFooterRequest>);
}
/**
 * Request model for InsertPageNumbers operation.
 */
export declare class InsertPageNumbersRequest {
    /**
     * A document name.
     */
    name: string;
    /**
     * with the page numbers settings.
     */
    pageNumber: PageNumber;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    revisionAuthor: string;
    /**
     * The date and time to use for revisions.
     */
    revisionDateTime: string;
    constructor(init?: Partial<InsertPageNumbersRequest>);
}
/**
 * Request model for InsertParagraph operation.
 */
export declare class InsertParagraphRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Paragraph data.
     */
    paragraph: ParagraphInsert;
    /**
     * Path to the node which contains paragraphs.
     */
    nodePath: string;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    revisionAuthor: string;
    /**
     * The date and time to use for revisions.
     */
    revisionDateTime: string;
    /**
     * Paragraph will be inserted before node with index.
     */
    insertBeforeNode: string;
    constructor(init?: Partial<InsertParagraphRequest>);
}
/**
 * Request model for InsertRun operation.
 */
export declare class InsertRunRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Path to parent paragraph.
     */
    paragraphPath: string;
    /**
     * Run data.
     */
    run: Run;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    revisionAuthor: string;
    /**
     * The date and time to use for revisions.
     */
    revisionDateTime: string;
    /**
     * Paragraph will be inserted before node with index.
     */
    insertBeforeNode: string;
    constructor(init?: Partial<InsertRunRequest>);
}
/**
 * Request model for InsertTable operation.
 */
export declare class InsertTableRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Path to the node, which contains tables.
     */
    nodePath: string;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    revisionAuthor: string;
    /**
     * The date and time to use for revisions.
     */
    revisionDateTime: string;
    /**
     * Table parameters/.
     */
    table: TableInsert;
    constructor(init?: Partial<InsertTableRequest>);
}
/**
 * Request model for InsertTableCell operation.
 */
export declare class InsertTableCellRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Path to table row.
     */
    tableRowPath: string;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    revisionAuthor: string;
    /**
     * The date and time to use for revisions.
     */
    revisionDateTime: string;
    /**
     * Table cell parameters/.
     */
    cell: TableCellInsert;
    constructor(init?: Partial<InsertTableCellRequest>);
}
/**
 * Request model for InsertTableRow operation.
 */
export declare class InsertTableRowRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Path to table.
     */
    tablePath: string;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    revisionAuthor: string;
    /**
     * The date and time to use for revisions.
     */
    revisionDateTime: string;
    /**
     * Table row parameters/.
     */
    row: TableRowInsert;
    constructor(init?: Partial<InsertTableRowRequest>);
}
/**
 * Request model for InsertTableWithoutNodePath operation.
 */
export declare class InsertTableWithoutNodePathRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    revisionAuthor: string;
    /**
     * The date and time to use for revisions.
     */
    revisionDateTime: string;
    /**
     * Table parameters/.
     */
    table: TableInsert;
    constructor(init?: Partial<InsertTableWithoutNodePathRequest>);
}
/**
 * Request model for InsertWatermarkImage operation.
 */
export declare class InsertWatermarkImageRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * File with image
     */
    imageFile: Readable;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    revisionAuthor: string;
    /**
     * The date and time to use for revisions.
     */
    revisionDateTime: string;
    /**
     * The watermark rotation angle.
     */
    rotationAngle: number;
    /**
     * The image file server full name. If the name is empty the image is expected in request content.
     */
    image: string;
    constructor(init?: Partial<InsertWatermarkImageRequest>);
}
/**
 * Request model for InsertWatermarkText operation.
 */
export declare class InsertWatermarkTextRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * with the watermark data.
     */
    watermarkText: WatermarkText;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    revisionAuthor: string;
    /**
     * The date and time to use for revisions.
     */
    revisionDateTime: string;
    constructor(init?: Partial<InsertWatermarkTextRequest>);
}
/**
 * Request model for LoadWebDocument operation.
 */
export declare class LoadWebDocumentRequest {
    /**
     * Parameters of loading.
     */
    data: LoadWebDocumentData;
    /**
     * Original document storage.
     */
    storage: string;
    constructor(init?: Partial<LoadWebDocumentRequest>);
}
/**
 * Request model for MoveFile operation.
 */
export declare class MoveFileRequest {
    /**
     * Destination file path e.g. '/dest.ext'
     */
    destPath: string;
    /**
     * Source file's path e.g. '/Folder 1/file.ext' or '/Bucket/Folder 1/file.ext'
     */
    srcPath: string;
    /**
     * Source storage name
     */
    srcStorageName: string;
    /**
     * Destination storage name
     */
    destStorageName: string;
    /**
     * File version ID to move
     */
    versionId: string;
    constructor(init?: Partial<MoveFileRequest>);
}
/**
 * Request model for MoveFolder operation.
 */
export declare class MoveFolderRequest {
    /**
     * Destination folder path to move to e.g '/dst'
     */
    destPath: string;
    /**
     * Source folder path e.g. /Folder1
     */
    srcPath: string;
    /**
     * Source storage name
     */
    srcStorageName: string;
    /**
     * Destination storage name
     */
    destStorageName: string;
    constructor(init?: Partial<MoveFolderRequest>);
}
/**
 * Request model for ProtectDocument operation.
 */
export declare class ProtectDocumentRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * with protection settings.
     */
    protectionRequest: ProtectionRequest;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    constructor(init?: Partial<ProtectDocumentRequest>);
}
/**
 * Request model for RejectAllRevisions operation.
 */
export declare class RejectAllRevisionsRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    constructor(init?: Partial<RejectAllRevisionsRequest>);
}
/**
 * Request model for RemoveRange operation.
 */
export declare class RemoveRangeRequest {
    /**
     * The document.
     */
    name: string;
    /**
     * The range start identifier. Identifier is the value of the \"nodeId\" field, which every document node has, extended with the prefix \"id\". It looks like \"id0.0.7\". Also values like \"image5\" and \"table3\" can be used as an identifier for images and tables, where the number is an index of the image/table.
     */
    rangeStartIdentifier: string;
    /**
     * The range end identifier.
     */
    rangeEndIdentifier: string;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    constructor(init?: Partial<RemoveRangeRequest>);
}
/**
 * Request model for RenderDrawingObject operation.
 */
export declare class RenderDrawingObjectRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * The destination format.
     */
    format: string;
    /**
     * Path to the node, which contains drawing objects.
     */
    nodePath: string;
    /**
     * Object index.
     */
    index: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Folder in filestorage with custom fonts.
     */
    fontsLocation: string;
    constructor(init?: Partial<RenderDrawingObjectRequest>);
}
/**
 * Request model for RenderDrawingObjectWithoutNodePath operation.
 */
export declare class RenderDrawingObjectWithoutNodePathRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * The destination format.
     */
    format: string;
    /**
     * Object index.
     */
    index: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Folder in filestorage with custom fonts.
     */
    fontsLocation: string;
    constructor(init?: Partial<RenderDrawingObjectWithoutNodePathRequest>);
}
/**
 * Request model for RenderMathObject operation.
 */
export declare class RenderMathObjectRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * The destination format.
     */
    format: string;
    /**
     * Path to the node, which contains office math objects.
     */
    nodePath: string;
    /**
     * Object index.
     */
    index: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Folder in filestorage with custom fonts.
     */
    fontsLocation: string;
    constructor(init?: Partial<RenderMathObjectRequest>);
}
/**
 * Request model for RenderMathObjectWithoutNodePath operation.
 */
export declare class RenderMathObjectWithoutNodePathRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * The destination format.
     */
    format: string;
    /**
     * Object index.
     */
    index: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Folder in filestorage with custom fonts.
     */
    fontsLocation: string;
    constructor(init?: Partial<RenderMathObjectWithoutNodePathRequest>);
}
/**
 * Request model for RenderPage operation.
 */
export declare class RenderPageRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Comment index.
     */
    pageIndex: number;
    /**
     * The destination format.
     */
    format: string;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Folder in filestorage with custom fonts.
     */
    fontsLocation: string;
    constructor(init?: Partial<RenderPageRequest>);
}
/**
 * Request model for RenderParagraph operation.
 */
export declare class RenderParagraphRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * The destination format.
     */
    format: string;
    /**
     * Path to the node, which contains paragraphs.
     */
    nodePath: string;
    /**
     * Object index.
     */
    index: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Folder in filestorage with custom fonts.
     */
    fontsLocation: string;
    constructor(init?: Partial<RenderParagraphRequest>);
}
/**
 * Request model for RenderParagraphWithoutNodePath operation.
 */
export declare class RenderParagraphWithoutNodePathRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * The destination format.
     */
    format: string;
    /**
     * Object index.
     */
    index: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Folder in filestorage with custom fonts.
     */
    fontsLocation: string;
    constructor(init?: Partial<RenderParagraphWithoutNodePathRequest>);
}
/**
 * Request model for RenderTable operation.
 */
export declare class RenderTableRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * The destination format.
     */
    format: string;
    /**
     * Path to the node, which contains tables.
     */
    nodePath: string;
    /**
     * Object index.
     */
    index: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Folder in filestorage with custom fonts.
     */
    fontsLocation: string;
    constructor(init?: Partial<RenderTableRequest>);
}
/**
 * Request model for RenderTableWithoutNodePath operation.
 */
export declare class RenderTableWithoutNodePathRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * The destination format.
     */
    format: string;
    /**
     * Object index.
     */
    index: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Folder in filestorage with custom fonts.
     */
    fontsLocation: string;
    constructor(init?: Partial<RenderTableWithoutNodePathRequest>);
}
/**
 * Request model for ReplaceText operation.
 */
export declare class ReplaceTextRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * with the replace operation settings.
     */
    replaceText: ReplaceTextParameters;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    revisionAuthor: string;
    /**
     * The date and time to use for revisions.
     */
    revisionDateTime: string;
    constructor(init?: Partial<ReplaceTextRequest>);
}
/**
 * Request model for ReplaceWithText operation.
 */
export declare class ReplaceWithTextRequest {
    /**
     * The document.
     */
    name: string;
    /**
     * The range start identifier. Identifier is the value of the \"nodeId\" field, which every document node has, extended with the prefix \"id\". It looks like \"id0.0.7\". Also values like \"image5\" and \"table3\" can be used as an identifier for images and tables, where the number is an index of the image/table.
     */
    rangeStartIdentifier: string;
    /**
     * Model with text for replacement.
     */
    rangeText: ReplaceRange;
    /**
     * The range end identifier.
     */
    rangeEndIdentifier: string;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    constructor(init?: Partial<ReplaceWithTextRequest>);
}
/**
 * Request model for ResetCache operation.
 */
export declare class ResetCacheRequest {
    constructor(init?: Partial<ResetCacheRequest>);
}
/**
 * Request model for SaveAs operation.
 */
export declare class SaveAsRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Save options.
     */
    saveOptionsData: SaveOptionsData;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Folder in filestorage with custom fonts.
     */
    fontsLocation: string;
    constructor(init?: Partial<SaveAsRequest>);
}
/**
 * Request model for SaveAsRange operation.
 */
export declare class SaveAsRangeRequest {
    /**
     * The document.
     */
    name: string;
    /**
     * The range start identifier. Identifier is the value of the \"nodeId\" field, which every document node has, extended with the prefix \"id\". It looks like \"id0.0.7\". Also values like \"image5\" and \"table3\" can be used as an identifier for images and tables, where the number is an index of the image/table.
     */
    rangeStartIdentifier: string;
    /**
     * Parameters of a new document.
     */
    documentParameters: RangeDocument;
    /**
     * The range end identifier.
     */
    rangeEndIdentifier: string;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    constructor(init?: Partial<SaveAsRangeRequest>);
}
/**
 * Request model for SaveAsTiff operation.
 */
export declare class SaveAsTiffRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Tiff save options.
     */
    saveOptions: TiffSaveOptionsData;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Use antialiasing flag.
     */
    useAntiAliasing: boolean;
    /**
     * Use high quality flag.
     */
    useHighQualityRendering: boolean;
    /**
     * Brightness for the generated images.
     */
    imageBrightness: number;
    /**
     * Color mode for the generated images.
     */
    imageColorMode: string;
    /**
     * The contrast for the generated images.
     */
    imageContrast: number;
    /**
     * The images numeral format.
     */
    numeralFormat: string;
    /**
     * Number of pages to render.
     */
    pageCount: number;
    /**
     * Page index to start rendering.
     */
    pageIndex: number;
    /**
     * Background image color.
     */
    paperColor: string;
    /**
     * The pixel format of generated images.
     */
    pixelFormat: string;
    /**
     * The resolution of generated images.
     */
    resolution: number;
    /**
     * Zoom factor for generated images.
     */
    scale: number;
    /**
     * The compression tipe.
     */
    tiffCompression: string;
    /**
     * Optional, default is Fallback.
     */
    dmlRenderingMode: string;
    /**
     * Optional, default is Simplified.
     */
    dmlEffectsRenderingMode: string;
    /**
     * Optional, Tiff binarization method, possible values are: FloydSteinbergDithering, Threshold.
     */
    tiffBinarizationMethod: string;
    /**
     * Optional. A value determining zip output or not.
     */
    zipOutput: boolean;
    /**
     * Folder in filestorage with custom fonts.
     */
    fontsLocation: string;
    constructor(init?: Partial<SaveAsTiffRequest>);
}
/**
 * Request model for Search operation.
 */
export declare class SearchRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * The regular expression used to find matches.
     */
    pattern: string;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    constructor(init?: Partial<SearchRequest>);
}
/**
 * Request model for SplitDocument operation.
 */
export declare class SplitDocumentRequest {
    /**
     * Original document name.
     */
    name: string;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    /**
     * Format to split.
     */
    format: string;
    /**
     * Start page.
     */
    from: number;
    /**
     * End page.
     */
    to: number;
    /**
     * ZipOutput or not.
     */
    zipOutput: boolean;
    /**
     * Folder in filestorage with custom fonts.
     */
    fontsLocation: string;
    constructor(init?: Partial<SplitDocumentRequest>);
}
/**
 * Request model for UnprotectDocument operation.
 */
export declare class UnprotectDocumentRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * with protection settings.
     */
    protectionRequest: ProtectionRequest;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    constructor(init?: Partial<UnprotectDocumentRequest>);
}
/**
 * Request model for UpdateBookmark operation.
 */
export declare class UpdateBookmarkRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * with new bookmark data.
     */
    bookmarkData: BookmarkData;
    /**
     * The bookmark name.
     */
    bookmarkName: string;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    revisionAuthor: string;
    /**
     * The date and time to use for revisions.
     */
    revisionDateTime: string;
    constructor(init?: Partial<UpdateBookmarkRequest>);
}
/**
 * Request model for UpdateBorder operation.
 */
export declare class UpdateBorderRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Border properties.
     */
    borderProperties: Border;
    /**
     * Path to the node with border(node should be paragraph, cell or row).
     */
    nodePath: string;
    /**
     * Border type.
     */
    borderType: 'Bottom' | 'Left' | 'Right' | 'Top' | 'Horizontal' | 'Vertical' | 'DiagonalDown' | 'DiagonalUp' | 'None';
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    revisionAuthor: string;
    /**
     * The date and time to use for revisions.
     */
    revisionDateTime: string;
    constructor(init?: Partial<UpdateBorderRequest>);
}
/**
 * Request model for UpdateComment operation.
 */
export declare class UpdateCommentRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * The comment index.
     */
    commentIndex: number;
    /**
     * The comment data.
     */
    comment: Comment;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    revisionAuthor: string;
    /**
     * The date and time to use for revisions.
     */
    revisionDateTime: string;
    constructor(init?: Partial<UpdateCommentRequest>);
}
/**
 * Request model for UpdateDrawingObject operation.
 */
export declare class UpdateDrawingObjectRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Drawing object parameters
     */
    drawingObject: string;
    /**
     * File with image
     */
    imageFile: Readable;
    /**
     * Path to the node, which contains collection of drawing objects.
     */
    nodePath: string;
    /**
     * Object index.
     */
    index: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    revisionAuthor: string;
    /**
     * The date and time to use for revisions.
     */
    revisionDateTime: string;
    constructor(init?: Partial<UpdateDrawingObjectRequest>);
}
/**
 * Request model for UpdateDrawingObjectWithoutNodePath operation.
 */
export declare class UpdateDrawingObjectWithoutNodePathRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Drawing object parameters
     */
    drawingObject: string;
    /**
     * File with image
     */
    imageFile: Readable;
    /**
     * Object index.
     */
    index: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    revisionAuthor: string;
    /**
     * The date and time to use for revisions.
     */
    revisionDateTime: string;
    constructor(init?: Partial<UpdateDrawingObjectWithoutNodePathRequest>);
}
/**
 * Request model for UpdateField operation.
 */
export declare class UpdateFieldRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Field data.
     */
    field: Field;
    /**
     * Path to the node, which contains collection of fields.
     */
    nodePath: string;
    /**
     * Object index.
     */
    index: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    revisionAuthor: string;
    /**
     * The date and time to use for revisions.
     */
    revisionDateTime: string;
    constructor(init?: Partial<UpdateFieldRequest>);
}
/**
 * Request model for UpdateFields operation.
 */
export declare class UpdateFieldsRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    constructor(init?: Partial<UpdateFieldsRequest>);
}
/**
 * Request model for UpdateFootnote operation.
 */
export declare class UpdateFootnoteRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Footnote data.
     */
    footnoteDto: Footnote;
    /**
     * Path to the node, which contains collection of footnotes.
     */
    nodePath: string;
    /**
     * Object index.
     */
    index: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    revisionAuthor: string;
    /**
     * The date and time to use for revisions.
     */
    revisionDateTime: string;
    constructor(init?: Partial<UpdateFootnoteRequest>);
}
/**
 * Request model for UpdateFootnoteWithoutNodePath operation.
 */
export declare class UpdateFootnoteWithoutNodePathRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Footnote data.
     */
    footnoteDto: Footnote;
    /**
     * Object index.
     */
    index: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    revisionAuthor: string;
    /**
     * The date and time to use for revisions.
     */
    revisionDateTime: string;
    constructor(init?: Partial<UpdateFootnoteWithoutNodePathRequest>);
}
/**
 * Request model for UpdateFormField operation.
 */
export declare class UpdateFormFieldRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * From field data.
     */
    formField: FormField;
    /**
     * Path to the node that contains collection of formfields.
     */
    nodePath: string;
    /**
     * Object index.
     */
    index: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    revisionAuthor: string;
    /**
     * The date and time to use for revisions.
     */
    revisionDateTime: string;
    constructor(init?: Partial<UpdateFormFieldRequest>);
}
/**
 * Request model for UpdateFormFieldWithoutNodePath operation.
 */
export declare class UpdateFormFieldWithoutNodePathRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * From field data.
     */
    formField: FormField;
    /**
     * Object index.
     */
    index: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    revisionAuthor: string;
    /**
     * The date and time to use for revisions.
     */
    revisionDateTime: string;
    constructor(init?: Partial<UpdateFormFieldWithoutNodePathRequest>);
}
/**
 * Request model for UpdateParagraphFormat operation.
 */
export declare class UpdateParagraphFormatRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Paragraph format object.
     */
    dto: ParagraphFormat;
    /**
     * Path to the node which contains paragraphs.
     */
    nodePath: string;
    /**
     * Object index.
     */
    index: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    revisionAuthor: string;
    /**
     * The date and time to use for revisions.
     */
    revisionDateTime: string;
    constructor(init?: Partial<UpdateParagraphFormatRequest>);
}
/**
 * Request model for UpdateRun operation.
 */
export declare class UpdateRunRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Run data.
     */
    run: Run;
    /**
     * Path to parent paragraph.
     */
    paragraphPath: string;
    /**
     * Object index.
     */
    index: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    revisionAuthor: string;
    /**
     * The date and time to use for revisions.
     */
    revisionDateTime: string;
    constructor(init?: Partial<UpdateRunRequest>);
}
/**
 * Request model for UpdateRunFont operation.
 */
export declare class UpdateRunFontRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Font dto object.
     */
    fontDto: Font;
    /**
     * Path to parent paragraph.
     */
    paragraphPath: string;
    /**
     * Object index.
     */
    index: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    revisionAuthor: string;
    /**
     * The date and time to use for revisions.
     */
    revisionDateTime: string;
    constructor(init?: Partial<UpdateRunFontRequest>);
}
/**
 * Request model for UpdateSectionPageSetup operation.
 */
export declare class UpdateSectionPageSetupRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Section index.
     */
    sectionIndex: number;
    /**
     * Page setup properties dto.
     */
    pageSetup: PageSetup;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    revisionAuthor: string;
    /**
     * The date and time to use for revisions.
     */
    revisionDateTime: string;
    constructor(init?: Partial<UpdateSectionPageSetupRequest>);
}
/**
 * Request model for UpdateTableCellFormat operation.
 */
export declare class UpdateTableCellFormatRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Path to table row.
     */
    tableRowPath: string;
    /**
     * Object index.
     */
    index: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    revisionAuthor: string;
    /**
     * The date and time to use for revisions.
     */
    revisionDateTime: string;
    /**
     * The properties.
     */
    format: TableCellFormat;
    constructor(init?: Partial<UpdateTableCellFormatRequest>);
}
/**
 * Request model for UpdateTableProperties operation.
 */
export declare class UpdateTablePropertiesRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Path to the node, which contains tables.
     */
    nodePath: string;
    /**
     * Object index.
     */
    index: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    revisionAuthor: string;
    /**
     * The date and time to use for revisions.
     */
    revisionDateTime: string;
    /**
     * The properties.
     */
    properties: TableProperties;
    constructor(init?: Partial<UpdateTablePropertiesRequest>);
}
/**
 * Request model for UpdateTablePropertiesWithoutNodePath operation.
 */
export declare class UpdateTablePropertiesWithoutNodePathRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Object index.
     */
    index: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    revisionAuthor: string;
    /**
     * The date and time to use for revisions.
     */
    revisionDateTime: string;
    /**
     * The properties.
     */
    properties: TableProperties;
    constructor(init?: Partial<UpdateTablePropertiesWithoutNodePathRequest>);
}
/**
 * Request model for UpdateTableRowFormat operation.
 */
export declare class UpdateTableRowFormatRequest {
    /**
     * The document name.
     */
    name: string;
    /**
     * Path to table.
     */
    tablePath: string;
    /**
     * Object index.
     */
    index: number;
    /**
     * Original document folder.
     */
    folder: string;
    /**
     * Original document storage.
     */
    storage: string;
    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    loadEncoding: string;
    /**
     * Password for opening an encrypted document.
     */
    password: string;
    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    destFileName: string;
    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    revisionAuthor: string;
    /**
     * The date and time to use for revisions.
     */
    revisionDateTime: string;
    /**
     * Table row format.
     */
    format: TableRowFormat;
    constructor(init?: Partial<UpdateTableRowFormatRequest>);
}
/**
 * Request model for UploadFile operation.
 */
export declare class UploadFileRequest {
    /**
     * File to upload
     */
    fileContent: Readable;
    /**
     * Path where to upload including filename and extension e.g. /file.ext or /Folder 1/file.ext              If the content is multipart and path does not contains the file name it tries to get them from filename parameter              from Content-Disposition header.
     */
    path: string;
    /**
     * Storage name
     */
    storageName: string;
    constructor(init?: Partial<UploadFileRequest>);
}
