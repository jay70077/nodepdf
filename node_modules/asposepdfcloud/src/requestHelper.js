"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const objectSerializer_1 = require("./objectSerializer");
var superagent = require("superagent");
function invokeApiMethod(requestOptions, confguration, notApplyAuthToRequest, postData) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            return yield invokeApiMethodInternal(requestOptions, confguration, notApplyAuthToRequest, postData);
        }
        catch (e) {
            if (e instanceof NeedRepeatException) {
                return yield invokeApiMethodInternal(requestOptions, confguration, notApplyAuthToRequest, postData);
            }
            throw e;
        }
    });
}
exports.invokeApiMethod = invokeApiMethod;
function addQueryParameterToUrl(url, queryParameters, parameterName, parameterValue) {
    if (parameterValue !== undefined) {
        if (url.indexOf("{" + parameterName + "}") >= 0) {
            url = url.replace("{" + parameterName + "}", String(parameterValue));
        }
        else {
            queryParameters[parameterName] = String(parameterValue);
        }
    }
    else {
        url = url.replace("/{" + parameterName + "}", "");
    }
    return url;
}
exports.addQueryParameterToUrl = addQueryParameterToUrl;
function invokeApiMethodInternal(requestOptions, confguration, notApplyAuthToRequest, postData) {
    return __awaiter(this, void 0, void 0, function* () {
        let sa = superagent(requestOptions.method, requestOptions["uri"]);
        const auth = confguration.authentication;
        if (!notApplyAuthToRequest) {
            yield auth.applyToRequest(requestOptions, confguration);
        }
        if (requestOptions.form) {
            sa.type('form');
            sa.send(requestOptions.form);
        }
        else if (postData) {
            sa.type('application/octet-stream');
            sa.set("Content-Length", postData.length);
            sa.send(postData);
        }
        else if (requestOptions.body) {
            sa.send(requestOptions.body);
        }
        sa.query(requestOptions.qs);
        sa.set("User-Agent", "pdf nodejs sdk");
        sa.set("x-aspose-client", "nodejs sdk");
        sa.set("x-aspose-client-version", "18.10.0");
        if (!requestOptions.headers) {
            requestOptions.headers = {};
        }
        if (!notApplyAuthToRequest) {
            sa.set("Authorization", requestOptions.headers.Authorization);
        }
        if (requestOptions.json) {
            sa.accept('json');
        }
        else {
            sa.responseType('blob');
        }
        return new Promise((resolve, reject) => {
            sa.catch((err) => __awaiter(this, void 0, void 0, function* () {
                if (err.status === 401 && !notApplyAuthToRequest) {
                    yield auth.handle401response(confguration);
                    reject(new NeedRepeatException());
                }
                else {
                    reject(err);
                }
            }));
            sa.then((response) => __awaiter(this, void 0, void 0, function* () {
                if (response.status >= 200 && response.status <= 299) {
                    resolve(response);
                }
                else {
                    try {
                        let bodyContent = response.body;
                        if (bodyContent instanceof Buffer) {
                            bodyContent = JSON.parse(bodyContent.toString("utf8"));
                        }
                        const result = objectSerializer_1.ObjectSerializer.deserialize(bodyContent, "SaaSposeResponse");
                        reject({ message: result.message, code: response.status });
                    }
                    catch (error) {
                        reject({ message: "Error while parse server error: " + error });
                    }
                }
            }));
        });
    });
}
class NeedRepeatException extends Error {
}
//# sourceMappingURL=requestHelper.js.map